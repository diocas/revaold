// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protocol.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	protocol.proto

It has these top-level messages:
	TagReq
	Tag
	TagResponse
	IsPublicLinkProtectedResponse
	ForgePublicLinkTokenReq
	ForgePublicLinkTokenResponse
	VerifyPublicLinkTokenReq
	VerifyPublicLinkTokenResponse
	EmptyResponse
	EmptyReq
	QuotaReq
	QuotaResponse
	UserResponse
	User
	TxInfoResponse
	TxInfo
	ForgeUserTokenReq
	TokenResponse
	TokenReq
	MetadataResponse
	Metadata
	PathReq
	MoveReq
	TxChunk
	WriteSummaryResponse
	WriteSummary
	TxEnd
	DataChunkResponse
	DataChunk
	RevisionResponse
	Revision
	RevisionReq
	RecycleEntryResponse
	RecycleEntry
	RecycleEntryReq
	LinkPermissions
	NewLinkReq
	UpdateLinkReq
	PublicLinkResponse
	ShareRecipient
	ACLReq
	PublicLink
	PublicLinkTokenReq
	ShareIDReq
	FolderShareResponse
	FolderShare
	ReceivedShareResponse
	NewFolderShareReq
	UpdateFolderShareReq
	UnshareFolderReq
	ListPublicLinksReq
	ListFolderSharesReq
	ReceivedShareReq
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_OK                           StatusCode = 0
	StatusCode_UNKNOWN                      StatusCode = 1
	StatusCode_STORAGE_NOT_FOUND            StatusCode = 2
	StatusCode_STORAGE_ALREADY_EXISTS       StatusCode = 3
	StatusCode_STORAGE_PERMISSIONDENIED     StatusCode = 4
	StatusCode_CONTEXT_USER_REQUIRED        StatusCode = 5
	StatusCode_PATH_INVALID                 StatusCode = 6
	StatusCode_PUBLIC_LINK_NOT_FOUND        StatusCode = 7
	StatusCode_PUBLIC_LINK_INVALID_DATE     StatusCode = 8
	StatusCode_PUBLIC_LINK_INVALID_PASSWORD StatusCode = 9
	StatusCode_STORAGE_NOT_SUPPORTED        StatusCode = 10
	StatusCode_USER_NOT_FOUND               StatusCode = 11
	StatusCode_TOKEN_INVALID                StatusCode = 12
	StatusCode_FOLDER_SHARE_NOT_FOUND       StatusCode = 13
)

var StatusCode_name = map[int32]string{
	0:  "OK",
	1:  "UNKNOWN",
	2:  "STORAGE_NOT_FOUND",
	3:  "STORAGE_ALREADY_EXISTS",
	4:  "STORAGE_PERMISSIONDENIED",
	5:  "CONTEXT_USER_REQUIRED",
	6:  "PATH_INVALID",
	7:  "PUBLIC_LINK_NOT_FOUND",
	8:  "PUBLIC_LINK_INVALID_DATE",
	9:  "PUBLIC_LINK_INVALID_PASSWORD",
	10: "STORAGE_NOT_SUPPORTED",
	11: "USER_NOT_FOUND",
	12: "TOKEN_INVALID",
	13: "FOLDER_SHARE_NOT_FOUND",
}
var StatusCode_value = map[string]int32{
	"OK":                           0,
	"UNKNOWN":                      1,
	"STORAGE_NOT_FOUND":            2,
	"STORAGE_ALREADY_EXISTS":       3,
	"STORAGE_PERMISSIONDENIED":     4,
	"CONTEXT_USER_REQUIRED":        5,
	"PATH_INVALID":                 6,
	"PUBLIC_LINK_NOT_FOUND":        7,
	"PUBLIC_LINK_INVALID_DATE":     8,
	"PUBLIC_LINK_INVALID_PASSWORD": 9,
	"STORAGE_NOT_SUPPORTED":        10,
	"USER_NOT_FOUND":               11,
	"TOKEN_INVALID":                12,
	"FOLDER_SHARE_NOT_FOUND":       13,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Tag_ItemType int32

const (
	Tag_FOLDER Tag_ItemType = 0
	Tag_FILE   Tag_ItemType = 1
)

var Tag_ItemType_name = map[int32]string{
	0: "FOLDER",
	1: "FILE",
}
var Tag_ItemType_value = map[string]int32{
	"FOLDER": 0,
	"FILE":   1,
}

func (x Tag_ItemType) String() string {
	return proto.EnumName(Tag_ItemType_name, int32(x))
}
func (Tag_ItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type ShareRecipient_RecipientType int32

const (
	ShareRecipient_USER  ShareRecipient_RecipientType = 0
	ShareRecipient_GROUP ShareRecipient_RecipientType = 1
	ShareRecipient_UNIX  ShareRecipient_RecipientType = 2
)

var ShareRecipient_RecipientType_name = map[int32]string{
	0: "USER",
	1: "GROUP",
	2: "UNIX",
}
var ShareRecipient_RecipientType_value = map[string]int32{
	"USER":  0,
	"GROUP": 1,
	"UNIX":  2,
}

func (x ShareRecipient_RecipientType) String() string {
	return proto.EnumName(ShareRecipient_RecipientType_name, int32(x))
}
func (ShareRecipient_RecipientType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{39, 0}
}

type PublicLink_ItemType int32

const (
	PublicLink_FILE   PublicLink_ItemType = 0
	PublicLink_FOLDER PublicLink_ItemType = 1
)

var PublicLink_ItemType_name = map[int32]string{
	0: "FILE",
	1: "FOLDER",
}
var PublicLink_ItemType_value = map[string]int32{
	"FILE":   0,
	"FOLDER": 1,
}

func (x PublicLink_ItemType) String() string {
	return proto.EnumName(PublicLink_ItemType_name, int32(x))
}
func (PublicLink_ItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{41, 0} }

type FolderShare_State int32

const (
	FolderShare_ACCEPTED FolderShare_State = 0
	FolderShare_PENDING  FolderShare_State = 1
	FolderShare_REJECTED FolderShare_State = 2
)

var FolderShare_State_name = map[int32]string{
	0: "ACCEPTED",
	1: "PENDING",
	2: "REJECTED",
}
var FolderShare_State_value = map[string]int32{
	"ACCEPTED": 0,
	"PENDING":  1,
	"REJECTED": 2,
}

func (x FolderShare_State) String() string {
	return proto.EnumName(FolderShare_State_name, int32(x))
}
func (FolderShare_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{45, 0} }

type TagReq struct {
	TagKey string `protobuf:"bytes,1,opt,name=tag_key,json=tagKey" json:"tag_key,omitempty"`
	TagVal string `protobuf:"bytes,2,opt,name=tag_val,json=tagVal" json:"tag_val,omitempty"`
	Path   string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
}

func (m *TagReq) Reset()                    { *m = TagReq{} }
func (m *TagReq) String() string            { return proto.CompactTextString(m) }
func (*TagReq) ProtoMessage()               {}
func (*TagReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TagReq) GetTagKey() string {
	if m != nil {
		return m.TagKey
	}
	return ""
}

func (m *TagReq) GetTagVal() string {
	if m != nil {
		return m.TagVal
	}
	return ""
}

func (m *TagReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type Tag struct {
	Id           int64        `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	ItemType     Tag_ItemType `protobuf:"varint,2,opt,name=item_type,json=itemType,enum=api.Tag_ItemType" json:"item_type,omitempty"`
	Uid          string       `protobuf:"bytes,3,opt,name=uid" json:"uid,omitempty"`
	FileIdPrefix string       `protobuf:"bytes,4,opt,name=file_id_prefix,json=fileIdPrefix" json:"file_id_prefix,omitempty"`
	FileId       string       `protobuf:"bytes,5,opt,name=file_id,json=fileId" json:"file_id,omitempty"`
	TagKey       string       `protobuf:"bytes,6,opt,name=tag_key,json=tagKey" json:"tag_key,omitempty"`
	TagValue     string       `protobuf:"bytes,7,opt,name=tag_value,json=tagValue" json:"tag_value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Tag) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Tag) GetItemType() Tag_ItemType {
	if m != nil {
		return m.ItemType
	}
	return Tag_FOLDER
}

func (m *Tag) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Tag) GetFileIdPrefix() string {
	if m != nil {
		return m.FileIdPrefix
	}
	return ""
}

func (m *Tag) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Tag) GetTagKey() string {
	if m != nil {
		return m.TagKey
	}
	return ""
}

func (m *Tag) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

type TagResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Tag    *Tag       `protobuf:"bytes,2,opt,name=tag" json:"tag,omitempty"`
}

func (m *TagResponse) Reset()                    { *m = TagResponse{} }
func (m *TagResponse) String() string            { return proto.CompactTextString(m) }
func (*TagResponse) ProtoMessage()               {}
func (*TagResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TagResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *TagResponse) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type IsPublicLinkProtectedResponse struct {
	Status    StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Protected bool       `protobuf:"varint,2,opt,name=protected" json:"protected,omitempty"`
}

func (m *IsPublicLinkProtectedResponse) Reset()                    { *m = IsPublicLinkProtectedResponse{} }
func (m *IsPublicLinkProtectedResponse) String() string            { return proto.CompactTextString(m) }
func (*IsPublicLinkProtectedResponse) ProtoMessage()               {}
func (*IsPublicLinkProtectedResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IsPublicLinkProtectedResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *IsPublicLinkProtectedResponse) GetProtected() bool {
	if m != nil {
		return m.Protected
	}
	return false
}

type ForgePublicLinkTokenReq struct {
	Token    string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *ForgePublicLinkTokenReq) Reset()                    { *m = ForgePublicLinkTokenReq{} }
func (m *ForgePublicLinkTokenReq) String() string            { return proto.CompactTextString(m) }
func (*ForgePublicLinkTokenReq) ProtoMessage()               {}
func (*ForgePublicLinkTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ForgePublicLinkTokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ForgePublicLinkTokenReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type ForgePublicLinkTokenResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Valid  bool       `protobuf:"varint,2,opt,name=valid" json:"valid,omitempty"`
}

func (m *ForgePublicLinkTokenResponse) Reset()                    { *m = ForgePublicLinkTokenResponse{} }
func (m *ForgePublicLinkTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*ForgePublicLinkTokenResponse) ProtoMessage()               {}
func (*ForgePublicLinkTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ForgePublicLinkTokenResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *ForgePublicLinkTokenResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

type VerifyPublicLinkTokenReq struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *VerifyPublicLinkTokenReq) Reset()                    { *m = VerifyPublicLinkTokenReq{} }
func (m *VerifyPublicLinkTokenReq) String() string            { return proto.CompactTextString(m) }
func (*VerifyPublicLinkTokenReq) ProtoMessage()               {}
func (*VerifyPublicLinkTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *VerifyPublicLinkTokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyPublicLinkTokenResponse struct {
	Status     StatusCode  `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	PublicLink *PublicLink `protobuf:"bytes,2,opt,name=public_link,json=publicLink" json:"public_link,omitempty"`
}

func (m *VerifyPublicLinkTokenResponse) Reset()                    { *m = VerifyPublicLinkTokenResponse{} }
func (m *VerifyPublicLinkTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyPublicLinkTokenResponse) ProtoMessage()               {}
func (*VerifyPublicLinkTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *VerifyPublicLinkTokenResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *VerifyPublicLinkTokenResponse) GetPublicLink() *PublicLink {
	if m != nil {
		return m.PublicLink
	}
	return nil
}

type EmptyResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *EmptyResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

type EmptyReq struct {
}

func (m *EmptyReq) Reset()                    { *m = EmptyReq{} }
func (m *EmptyReq) String() string            { return proto.CompactTextString(m) }
func (*EmptyReq) ProtoMessage()               {}
func (*EmptyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type QuotaReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *QuotaReq) Reset()                    { *m = QuotaReq{} }
func (m *QuotaReq) String() string            { return proto.CompactTextString(m) }
func (*QuotaReq) ProtoMessage()               {}
func (*QuotaReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *QuotaReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type QuotaResponse struct {
	Status     StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	TotalBytes int64      `protobuf:"varint,2,opt,name=total_bytes,json=totalBytes" json:"total_bytes,omitempty"`
	UsedBytes  int64      `protobuf:"varint,3,opt,name=used_bytes,json=usedBytes" json:"used_bytes,omitempty"`
}

func (m *QuotaResponse) Reset()                    { *m = QuotaResponse{} }
func (m *QuotaResponse) String() string            { return proto.CompactTextString(m) }
func (*QuotaResponse) ProtoMessage()               {}
func (*QuotaResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *QuotaResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *QuotaResponse) GetTotalBytes() int64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *QuotaResponse) GetUsedBytes() int64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

type UserResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	User   *User      `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *UserResponse) Reset()                    { *m = UserResponse{} }
func (m *UserResponse) String() string            { return proto.CompactTextString(m) }
func (*UserResponse) ProtoMessage()               {}
func (*UserResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UserResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *UserResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type User struct {
	AccountId   string   `protobuf:"bytes,1,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
	Groups      []string `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty"`
	DisplayName string   `protobuf:"bytes,3,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *User) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *User) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *User) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

type TxInfoResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	TxInfo *TxInfo    `protobuf:"bytes,2,opt,name=txInfo" json:"txInfo,omitempty"`
}

func (m *TxInfoResponse) Reset()                    { *m = TxInfoResponse{} }
func (m *TxInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*TxInfoResponse) ProtoMessage()               {}
func (*TxInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *TxInfoResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *TxInfoResponse) GetTxInfo() *TxInfo {
	if m != nil {
		return m.TxInfo
	}
	return nil
}

type TxInfo struct {
	TxId string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
}

func (m *TxInfo) Reset()                    { *m = TxInfo{} }
func (m *TxInfo) String() string            { return proto.CompactTextString(m) }
func (*TxInfo) ProtoMessage()               {}
func (*TxInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *TxInfo) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type ForgeUserTokenReq struct {
	ClientId     string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	ClientSecret string `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
}

func (m *ForgeUserTokenReq) Reset()                    { *m = ForgeUserTokenReq{} }
func (m *ForgeUserTokenReq) String() string            { return proto.CompactTextString(m) }
func (*ForgeUserTokenReq) ProtoMessage()               {}
func (*ForgeUserTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ForgeUserTokenReq) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ForgeUserTokenReq) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

type TokenResponse struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Token  string     `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *TokenResponse) Reset()                    { *m = TokenResponse{} }
func (m *TokenResponse) String() string            { return proto.CompactTextString(m) }
func (*TokenResponse) ProtoMessage()               {}
func (*TokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *TokenResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *TokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type TokenReq struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *TokenReq) Reset()                    { *m = TokenReq{} }
func (m *TokenReq) String() string            { return proto.CompactTextString(m) }
func (*TokenReq) ProtoMessage()               {}
func (*TokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *TokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type MetadataResponse struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Metadata *Metadata  `protobuf:"bytes,2,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *MetadataResponse) Reset()                    { *m = MetadataResponse{} }
func (m *MetadataResponse) String() string            { return proto.CompactTextString(m) }
func (*MetadataResponse) ProtoMessage()               {}
func (*MetadataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *MetadataResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *MetadataResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Metadata struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path        string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Size        uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Mtime       uint64 `protobuf:"varint,4,opt,name=mtime" json:"mtime,omitempty"`
	IsDir       bool   `protobuf:"varint,5,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
	Etag        string `protobuf:"bytes,6,opt,name=etag" json:"etag,omitempty"`
	Checksum    string `protobuf:"bytes,7,opt,name=checksum" json:"checksum,omitempty"`
	DerefPath   string `protobuf:"bytes,8,opt,name=deref_path,json=derefPath" json:"deref_path,omitempty"`
	IsReadOnly  bool   `protobuf:"varint,9,opt,name=is_read_only,json=isReadOnly" json:"is_read_only,omitempty"`
	IsShareable bool   `protobuf:"varint,10,opt,name=is_shareable,json=isShareable" json:"is_shareable,omitempty"`
	Mime        string `protobuf:"bytes,11,opt,name=mime" json:"mime,omitempty"`
	Sys         []byte `protobuf:"bytes,12,opt,name=sys,proto3" json:"sys,omitempty"`
	TreeCount   uint64 `protobuf:"varint,13,opt,name=tree_count,json=treeCount" json:"tree_count,omitempty"`
	// EOS filesytem extended metadata records
	EosFile     string `protobuf:"bytes,14,opt,name=eos_file,json=eosFile" json:"eos_file,omitempty"`
	EosInstance string `protobuf:"bytes,15,opt,name=eos_instance,json=eosInstance" json:"eos_instance,omitempty"`
	// Share extended metadata records
	ShareTarget string `protobuf:"bytes,16,opt,name=share_target,json=shareTarget" json:"share_target,omitempty"`
	// Migration extended metadata records
	MigId   string `protobuf:"bytes,17,opt,name=mig_id,json=migId" json:"mig_id,omitempty"`
	MigPath string `protobuf:"bytes,18,opt,name=mig_path,json=migPath" json:"mig_path,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Metadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Metadata) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Metadata) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Metadata) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *Metadata) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

func (m *Metadata) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Metadata) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *Metadata) GetDerefPath() string {
	if m != nil {
		return m.DerefPath
	}
	return ""
}

func (m *Metadata) GetIsReadOnly() bool {
	if m != nil {
		return m.IsReadOnly
	}
	return false
}

func (m *Metadata) GetIsShareable() bool {
	if m != nil {
		return m.IsShareable
	}
	return false
}

func (m *Metadata) GetMime() string {
	if m != nil {
		return m.Mime
	}
	return ""
}

func (m *Metadata) GetSys() []byte {
	if m != nil {
		return m.Sys
	}
	return nil
}

func (m *Metadata) GetTreeCount() uint64 {
	if m != nil {
		return m.TreeCount
	}
	return 0
}

func (m *Metadata) GetEosFile() string {
	if m != nil {
		return m.EosFile
	}
	return ""
}

func (m *Metadata) GetEosInstance() string {
	if m != nil {
		return m.EosInstance
	}
	return ""
}

func (m *Metadata) GetShareTarget() string {
	if m != nil {
		return m.ShareTarget
	}
	return ""
}

func (m *Metadata) GetMigId() string {
	if m != nil {
		return m.MigId
	}
	return ""
}

func (m *Metadata) GetMigPath() string {
	if m != nil {
		return m.MigPath
	}
	return ""
}

type PathReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *PathReq) Reset()                    { *m = PathReq{} }
func (m *PathReq) String() string            { return proto.CompactTextString(m) }
func (*PathReq) ProtoMessage()               {}
func (*PathReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *PathReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type MoveReq struct {
	OldPath string `protobuf:"bytes,1,opt,name=old_path,json=oldPath" json:"old_path,omitempty"`
	NewPath string `protobuf:"bytes,2,opt,name=new_path,json=newPath" json:"new_path,omitempty"`
}

func (m *MoveReq) Reset()                    { *m = MoveReq{} }
func (m *MoveReq) String() string            { return proto.CompactTextString(m) }
func (*MoveReq) ProtoMessage()               {}
func (*MoveReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *MoveReq) GetOldPath() string {
	if m != nil {
		return m.OldPath
	}
	return ""
}

func (m *MoveReq) GetNewPath() string {
	if m != nil {
		return m.NewPath
	}
	return ""
}

// maybe add checksum data ?
type TxChunk struct {
	TxId   string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
	Length uint64 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	Offset uint64 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Data   []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TxChunk) Reset()                    { *m = TxChunk{} }
func (m *TxChunk) String() string            { return proto.CompactTextString(m) }
func (*TxChunk) ProtoMessage()               {}
func (*TxChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *TxChunk) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxChunk) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *TxChunk) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *TxChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteSummaryResponse struct {
	Status       StatusCode    `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	WriteSummary *WriteSummary `protobuf:"bytes,2,opt,name=writeSummary" json:"writeSummary,omitempty"`
}

func (m *WriteSummaryResponse) Reset()                    { *m = WriteSummaryResponse{} }
func (m *WriteSummaryResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteSummaryResponse) ProtoMessage()               {}
func (*WriteSummaryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *WriteSummaryResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *WriteSummaryResponse) GetWriteSummary() *WriteSummary {
	if m != nil {
		return m.WriteSummary
	}
	return nil
}

type WriteSummary struct {
	Nchunks   uint64 `protobuf:"varint,1,opt,name=nchunks" json:"nchunks,omitempty"`
	TotalSize uint64 `protobuf:"varint,2,opt,name=total_size,json=totalSize" json:"total_size,omitempty"`
}

func (m *WriteSummary) Reset()                    { *m = WriteSummary{} }
func (m *WriteSummary) String() string            { return proto.CompactTextString(m) }
func (*WriteSummary) ProtoMessage()               {}
func (*WriteSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *WriteSummary) GetNchunks() uint64 {
	if m != nil {
		return m.Nchunks
	}
	return 0
}

func (m *WriteSummary) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type TxEnd struct {
	TxId     string `protobuf:"bytes,1,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
	Path     string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Checksum string `protobuf:"bytes,3,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *TxEnd) Reset()                    { *m = TxEnd{} }
func (m *TxEnd) String() string            { return proto.CompactTextString(m) }
func (*TxEnd) ProtoMessage()               {}
func (*TxEnd) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *TxEnd) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxEnd) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TxEnd) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type DataChunkResponse struct {
	Status    StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	DataChunk *DataChunk `protobuf:"bytes,2,opt,name=dataChunk" json:"dataChunk,omitempty"`
}

func (m *DataChunkResponse) Reset()                    { *m = DataChunkResponse{} }
func (m *DataChunkResponse) String() string            { return proto.CompactTextString(m) }
func (*DataChunkResponse) ProtoMessage()               {}
func (*DataChunkResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *DataChunkResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *DataChunkResponse) GetDataChunk() *DataChunk {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataChunk struct {
	Length uint64 `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	Offset uint64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *DataChunk) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DataChunk) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DataChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RevisionResponse struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Revision *Revision  `protobuf:"bytes,2,opt,name=revision" json:"revision,omitempty"`
}

func (m *RevisionResponse) Reset()                    { *m = RevisionResponse{} }
func (m *RevisionResponse) String() string            { return proto.CompactTextString(m) }
func (*RevisionResponse) ProtoMessage()               {}
func (*RevisionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *RevisionResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *RevisionResponse) GetRevision() *Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

type Revision struct {
	RevKey string `protobuf:"bytes,1,opt,name=rev_key,json=revKey" json:"rev_key,omitempty"`
	Size   uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Mtime  uint64 `protobuf:"varint,3,opt,name=mtime" json:"mtime,omitempty"`
	IsDir  bool   `protobuf:"varint,4,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
}

func (m *Revision) Reset()                    { *m = Revision{} }
func (m *Revision) String() string            { return proto.CompactTextString(m) }
func (*Revision) ProtoMessage()               {}
func (*Revision) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *Revision) GetRevKey() string {
	if m != nil {
		return m.RevKey
	}
	return ""
}

func (m *Revision) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Revision) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *Revision) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

type RevisionReq struct {
	Path   string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	RevKey string `protobuf:"bytes,2,opt,name=rev_key,json=revKey" json:"rev_key,omitempty"`
}

func (m *RevisionReq) Reset()                    { *m = RevisionReq{} }
func (m *RevisionReq) String() string            { return proto.CompactTextString(m) }
func (*RevisionReq) ProtoMessage()               {}
func (*RevisionReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *RevisionReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RevisionReq) GetRevKey() string {
	if m != nil {
		return m.RevKey
	}
	return ""
}

type RecycleEntryResponse struct {
	Status       StatusCode    `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	RecycleEntry *RecycleEntry `protobuf:"bytes,2,opt,name=recycleEntry" json:"recycleEntry,omitempty"`
}

func (m *RecycleEntryResponse) Reset()                    { *m = RecycleEntryResponse{} }
func (m *RecycleEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntryResponse) ProtoMessage()               {}
func (*RecycleEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *RecycleEntryResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *RecycleEntryResponse) GetRecycleEntry() *RecycleEntry {
	if m != nil {
		return m.RecycleEntry
	}
	return nil
}

type RecycleEntry struct {
	RestorePath string `protobuf:"bytes,1,opt,name=restore_path,json=restorePath" json:"restore_path,omitempty"`
	RestoreKey  string `protobuf:"bytes,2,opt,name=restore_key,json=restoreKey" json:"restore_key,omitempty"`
	Size        uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	DelMtime    uint64 `protobuf:"varint,4,opt,name=del_mtime,json=delMtime" json:"del_mtime,omitempty"`
	IsDir       bool   `protobuf:"varint,5,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
}

func (m *RecycleEntry) Reset()                    { *m = RecycleEntry{} }
func (m *RecycleEntry) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntry) ProtoMessage()               {}
func (*RecycleEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *RecycleEntry) GetRestorePath() string {
	if m != nil {
		return m.RestorePath
	}
	return ""
}

func (m *RecycleEntry) GetRestoreKey() string {
	if m != nil {
		return m.RestoreKey
	}
	return ""
}

func (m *RecycleEntry) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *RecycleEntry) GetDelMtime() uint64 {
	if m != nil {
		return m.DelMtime
	}
	return 0
}

func (m *RecycleEntry) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

type RecycleEntryReq struct {
	RestoreKey string `protobuf:"bytes,1,opt,name=restore_key,json=restoreKey" json:"restore_key,omitempty"`
}

func (m *RecycleEntryReq) Reset()                    { *m = RecycleEntryReq{} }
func (m *RecycleEntryReq) String() string            { return proto.CompactTextString(m) }
func (*RecycleEntryReq) ProtoMessage()               {}
func (*RecycleEntryReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *RecycleEntryReq) GetRestoreKey() string {
	if m != nil {
		return m.RestoreKey
	}
	return ""
}

type LinkPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read" json:"read,omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write" json:"write,omitempty"`
}

func (m *LinkPermissions) Reset()                    { *m = LinkPermissions{} }
func (m *LinkPermissions) String() string            { return proto.CompactTextString(m) }
func (*LinkPermissions) ProtoMessage()               {}
func (*LinkPermissions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *LinkPermissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *LinkPermissions) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type NewLinkReq struct {
	Path     string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	ReadOnly bool   `protobuf:"varint,2,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	Expires  uint64 `protobuf:"varint,4,opt,name=expires" json:"expires,omitempty"`
}

func (m *NewLinkReq) Reset()                    { *m = NewLinkReq{} }
func (m *NewLinkReq) String() string            { return proto.CompactTextString(m) }
func (*NewLinkReq) ProtoMessage()               {}
func (*NewLinkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *NewLinkReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *NewLinkReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *NewLinkReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *NewLinkReq) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

type UpdateLinkReq struct {
	Id               string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	UpdatePassword   bool   `protobuf:"varint,2,opt,name=update_password,json=updatePassword" json:"update_password,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	UpdateExpiration bool   `protobuf:"varint,4,opt,name=update_expiration,json=updateExpiration" json:"update_expiration,omitempty"`
	Expiration       uint64 `protobuf:"varint,5,opt,name=expiration" json:"expiration,omitempty"`
	ReadOnly         bool   `protobuf:"varint,6,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	UpdateReadOnly   bool   `protobuf:"varint,7,opt,name=update_read_only,json=updateReadOnly" json:"update_read_only,omitempty"`
}

func (m *UpdateLinkReq) Reset()                    { *m = UpdateLinkReq{} }
func (m *UpdateLinkReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateLinkReq) ProtoMessage()               {}
func (*UpdateLinkReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *UpdateLinkReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateLinkReq) GetUpdatePassword() bool {
	if m != nil {
		return m.UpdatePassword
	}
	return false
}

func (m *UpdateLinkReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UpdateLinkReq) GetUpdateExpiration() bool {
	if m != nil {
		return m.UpdateExpiration
	}
	return false
}

func (m *UpdateLinkReq) GetExpiration() uint64 {
	if m != nil {
		return m.Expiration
	}
	return 0
}

func (m *UpdateLinkReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *UpdateLinkReq) GetUpdateReadOnly() bool {
	if m != nil {
		return m.UpdateReadOnly
	}
	return false
}

type PublicLinkResponse struct {
	Status     StatusCode  `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	PublicLink *PublicLink `protobuf:"bytes,2,opt,name=publicLink" json:"publicLink,omitempty"`
}

func (m *PublicLinkResponse) Reset()                    { *m = PublicLinkResponse{} }
func (m *PublicLinkResponse) String() string            { return proto.CompactTextString(m) }
func (*PublicLinkResponse) ProtoMessage()               {}
func (*PublicLinkResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *PublicLinkResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *PublicLinkResponse) GetPublicLink() *PublicLink {
	if m != nil {
		return m.PublicLink
	}
	return nil
}

type ShareRecipient struct {
	Identity string                       `protobuf:"bytes,1,opt,name=identity" json:"identity,omitempty"`
	Type     ShareRecipient_RecipientType `protobuf:"varint,2,opt,name=type,enum=api.ShareRecipient_RecipientType" json:"type,omitempty"`
}

func (m *ShareRecipient) Reset()                    { *m = ShareRecipient{} }
func (m *ShareRecipient) String() string            { return proto.CompactTextString(m) }
func (*ShareRecipient) ProtoMessage()               {}
func (*ShareRecipient) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *ShareRecipient) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *ShareRecipient) GetType() ShareRecipient_RecipientType {
	if m != nil {
		return m.Type
	}
	return ShareRecipient_USER
}

type ACLReq struct {
	Path      string          `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Recipient *ShareRecipient `protobuf:"bytes,2,opt,name=recipient" json:"recipient,omitempty"`
	ReadOnly  bool            `protobuf:"varint,3,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Shares    []*FolderShare  `protobuf:"bytes,4,rep,name=shares" json:"shares,omitempty"`
}

func (m *ACLReq) Reset()                    { *m = ACLReq{} }
func (m *ACLReq) String() string            { return proto.CompactTextString(m) }
func (*ACLReq) ProtoMessage()               {}
func (*ACLReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *ACLReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ACLReq) GetRecipient() *ShareRecipient {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *ACLReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *ACLReq) GetShares() []*FolderShare {
	if m != nil {
		return m.Shares
	}
	return nil
}

type PublicLink struct {
	Id        string              `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Token     string              `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	Path      string              `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	Protected bool                `protobuf:"varint,4,opt,name=protected" json:"protected,omitempty"`
	Expires   uint64              `protobuf:"varint,5,opt,name=expires" json:"expires,omitempty"`
	ReadOnly  bool                `protobuf:"varint,6,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Mtime     uint64              `protobuf:"varint,7,opt,name=mtime" json:"mtime,omitempty"`
	ItemType  PublicLink_ItemType `protobuf:"varint,8,opt,name=item_type,json=itemType,enum=api.PublicLink_ItemType" json:"item_type,omitempty"`
	OwnerId   string              `protobuf:"bytes,9,opt,name=owner_id,json=ownerId" json:"owner_id,omitempty"`
	Name      string              `protobuf:"bytes,10,opt,name=name" json:"name,omitempty"`
}

func (m *PublicLink) Reset()                    { *m = PublicLink{} }
func (m *PublicLink) String() string            { return proto.CompactTextString(m) }
func (*PublicLink) ProtoMessage()               {}
func (*PublicLink) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *PublicLink) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PublicLink) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *PublicLink) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PublicLink) GetProtected() bool {
	if m != nil {
		return m.Protected
	}
	return false
}

func (m *PublicLink) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *PublicLink) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *PublicLink) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *PublicLink) GetItemType() PublicLink_ItemType {
	if m != nil {
		return m.ItemType
	}
	return PublicLink_FILE
}

func (m *PublicLink) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *PublicLink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PublicLinkTokenReq struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *PublicLinkTokenReq) Reset()                    { *m = PublicLinkTokenReq{} }
func (m *PublicLinkTokenReq) String() string            { return proto.CompactTextString(m) }
func (*PublicLinkTokenReq) ProtoMessage()               {}
func (*PublicLinkTokenReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *PublicLinkTokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ShareIDReq struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ShareIDReq) Reset()                    { *m = ShareIDReq{} }
func (m *ShareIDReq) String() string            { return proto.CompactTextString(m) }
func (*ShareIDReq) ProtoMessage()               {}
func (*ShareIDReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *ShareIDReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type FolderShareResponse struct {
	Status      StatusCode   `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	FolderShare *FolderShare `protobuf:"bytes,2,opt,name=folderShare" json:"folderShare,omitempty"`
}

func (m *FolderShareResponse) Reset()                    { *m = FolderShareResponse{} }
func (m *FolderShareResponse) String() string            { return proto.CompactTextString(m) }
func (*FolderShareResponse) ProtoMessage()               {}
func (*FolderShareResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *FolderShareResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *FolderShareResponse) GetFolderShare() *FolderShare {
	if m != nil {
		return m.FolderShare
	}
	return nil
}

type FolderShare struct {
	Id        string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Path      string            `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	OwnerId   string            `protobuf:"bytes,3,opt,name=owner_id,json=ownerId" json:"owner_id,omitempty"`
	Recipient *ShareRecipient   `protobuf:"bytes,4,opt,name=recipient" json:"recipient,omitempty"`
	ReadOnly  bool              `protobuf:"varint,5,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	Ctime     uint64            `protobuf:"varint,6,opt,name=ctime" json:"ctime,omitempty"`
	Mtime     uint64            `protobuf:"varint,7,opt,name=mtime" json:"mtime,omitempty"`
	Target    string            `protobuf:"bytes,8,opt,name=target" json:"target,omitempty"`
	State     FolderShare_State `protobuf:"varint,9,opt,name=state,enum=api.FolderShare_State" json:"state,omitempty"`
}

func (m *FolderShare) Reset()                    { *m = FolderShare{} }
func (m *FolderShare) String() string            { return proto.CompactTextString(m) }
func (*FolderShare) ProtoMessage()               {}
func (*FolderShare) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *FolderShare) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FolderShare) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FolderShare) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *FolderShare) GetRecipient() *ShareRecipient {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *FolderShare) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *FolderShare) GetCtime() uint64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *FolderShare) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *FolderShare) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *FolderShare) GetState() FolderShare_State {
	if m != nil {
		return m.State
	}
	return FolderShare_ACCEPTED
}

type ReceivedShareResponse struct {
	Status StatusCode   `protobuf:"varint,1,opt,name=status,enum=api.StatusCode" json:"status,omitempty"`
	Share  *FolderShare `protobuf:"bytes,2,opt,name=share" json:"share,omitempty"`
}

func (m *ReceivedShareResponse) Reset()                    { *m = ReceivedShareResponse{} }
func (m *ReceivedShareResponse) String() string            { return proto.CompactTextString(m) }
func (*ReceivedShareResponse) ProtoMessage()               {}
func (*ReceivedShareResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *ReceivedShareResponse) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_OK
}

func (m *ReceivedShareResponse) GetShare() *FolderShare {
	if m != nil {
		return m.Share
	}
	return nil
}

type NewFolderShareReq struct {
	Path      string          `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Recipient *ShareRecipient `protobuf:"bytes,2,opt,name=recipient" json:"recipient,omitempty"`
	ReadOnly  bool            `protobuf:"varint,3,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
}

func (m *NewFolderShareReq) Reset()                    { *m = NewFolderShareReq{} }
func (m *NewFolderShareReq) String() string            { return proto.CompactTextString(m) }
func (*NewFolderShareReq) ProtoMessage()               {}
func (*NewFolderShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *NewFolderShareReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *NewFolderShareReq) GetRecipient() *ShareRecipient {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *NewFolderShareReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type UpdateFolderShareReq struct {
	Id             string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	UpdateReadOnly bool   `protobuf:"varint,2,opt,name=update_read_only,json=updateReadOnly" json:"update_read_only,omitempty"`
	ReadOnly       bool   `protobuf:"varint,3,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
}

func (m *UpdateFolderShareReq) Reset()                    { *m = UpdateFolderShareReq{} }
func (m *UpdateFolderShareReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateFolderShareReq) ProtoMessage()               {}
func (*UpdateFolderShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *UpdateFolderShareReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateFolderShareReq) GetUpdateReadOnly() bool {
	if m != nil {
		return m.UpdateReadOnly
	}
	return false
}

func (m *UpdateFolderShareReq) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type UnshareFolderReq struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *UnshareFolderReq) Reset()                    { *m = UnshareFolderReq{} }
func (m *UnshareFolderReq) String() string            { return proto.CompactTextString(m) }
func (*UnshareFolderReq) ProtoMessage()               {}
func (*UnshareFolderReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *UnshareFolderReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ListPublicLinksReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *ListPublicLinksReq) Reset()                    { *m = ListPublicLinksReq{} }
func (m *ListPublicLinksReq) String() string            { return proto.CompactTextString(m) }
func (*ListPublicLinksReq) ProtoMessage()               {}
func (*ListPublicLinksReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *ListPublicLinksReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type ListFolderSharesReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *ListFolderSharesReq) Reset()                    { *m = ListFolderSharesReq{} }
func (m *ListFolderSharesReq) String() string            { return proto.CompactTextString(m) }
func (*ListFolderSharesReq) ProtoMessage()               {}
func (*ListFolderSharesReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *ListFolderSharesReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type ReceivedShareReq struct {
	ShareId string `protobuf:"bytes,1,opt,name=share_id,json=shareId" json:"share_id,omitempty"`
}

func (m *ReceivedShareReq) Reset()                    { *m = ReceivedShareReq{} }
func (m *ReceivedShareReq) String() string            { return proto.CompactTextString(m) }
func (*ReceivedShareReq) ProtoMessage()               {}
func (*ReceivedShareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *ReceivedShareReq) GetShareId() string {
	if m != nil {
		return m.ShareId
	}
	return ""
}

func init() {
	proto.RegisterType((*TagReq)(nil), "api.TagReq")
	proto.RegisterType((*Tag)(nil), "api.Tag")
	proto.RegisterType((*TagResponse)(nil), "api.TagResponse")
	proto.RegisterType((*IsPublicLinkProtectedResponse)(nil), "api.IsPublicLinkProtectedResponse")
	proto.RegisterType((*ForgePublicLinkTokenReq)(nil), "api.ForgePublicLinkTokenReq")
	proto.RegisterType((*ForgePublicLinkTokenResponse)(nil), "api.ForgePublicLinkTokenResponse")
	proto.RegisterType((*VerifyPublicLinkTokenReq)(nil), "api.VerifyPublicLinkTokenReq")
	proto.RegisterType((*VerifyPublicLinkTokenResponse)(nil), "api.VerifyPublicLinkTokenResponse")
	proto.RegisterType((*EmptyResponse)(nil), "api.EmptyResponse")
	proto.RegisterType((*EmptyReq)(nil), "api.EmptyReq")
	proto.RegisterType((*QuotaReq)(nil), "api.QuotaReq")
	proto.RegisterType((*QuotaResponse)(nil), "api.QuotaResponse")
	proto.RegisterType((*UserResponse)(nil), "api.UserResponse")
	proto.RegisterType((*User)(nil), "api.User")
	proto.RegisterType((*TxInfoResponse)(nil), "api.TxInfoResponse")
	proto.RegisterType((*TxInfo)(nil), "api.TxInfo")
	proto.RegisterType((*ForgeUserTokenReq)(nil), "api.ForgeUserTokenReq")
	proto.RegisterType((*TokenResponse)(nil), "api.TokenResponse")
	proto.RegisterType((*TokenReq)(nil), "api.TokenReq")
	proto.RegisterType((*MetadataResponse)(nil), "api.MetadataResponse")
	proto.RegisterType((*Metadata)(nil), "api.Metadata")
	proto.RegisterType((*PathReq)(nil), "api.PathReq")
	proto.RegisterType((*MoveReq)(nil), "api.MoveReq")
	proto.RegisterType((*TxChunk)(nil), "api.TxChunk")
	proto.RegisterType((*WriteSummaryResponse)(nil), "api.WriteSummaryResponse")
	proto.RegisterType((*WriteSummary)(nil), "api.WriteSummary")
	proto.RegisterType((*TxEnd)(nil), "api.TxEnd")
	proto.RegisterType((*DataChunkResponse)(nil), "api.DataChunkResponse")
	proto.RegisterType((*DataChunk)(nil), "api.DataChunk")
	proto.RegisterType((*RevisionResponse)(nil), "api.RevisionResponse")
	proto.RegisterType((*Revision)(nil), "api.Revision")
	proto.RegisterType((*RevisionReq)(nil), "api.RevisionReq")
	proto.RegisterType((*RecycleEntryResponse)(nil), "api.RecycleEntryResponse")
	proto.RegisterType((*RecycleEntry)(nil), "api.RecycleEntry")
	proto.RegisterType((*RecycleEntryReq)(nil), "api.RecycleEntryReq")
	proto.RegisterType((*LinkPermissions)(nil), "api.LinkPermissions")
	proto.RegisterType((*NewLinkReq)(nil), "api.NewLinkReq")
	proto.RegisterType((*UpdateLinkReq)(nil), "api.UpdateLinkReq")
	proto.RegisterType((*PublicLinkResponse)(nil), "api.PublicLinkResponse")
	proto.RegisterType((*ShareRecipient)(nil), "api.ShareRecipient")
	proto.RegisterType((*ACLReq)(nil), "api.ACLReq")
	proto.RegisterType((*PublicLink)(nil), "api.PublicLink")
	proto.RegisterType((*PublicLinkTokenReq)(nil), "api.PublicLinkTokenReq")
	proto.RegisterType((*ShareIDReq)(nil), "api.ShareIDReq")
	proto.RegisterType((*FolderShareResponse)(nil), "api.FolderShareResponse")
	proto.RegisterType((*FolderShare)(nil), "api.FolderShare")
	proto.RegisterType((*ReceivedShareResponse)(nil), "api.ReceivedShareResponse")
	proto.RegisterType((*NewFolderShareReq)(nil), "api.NewFolderShareReq")
	proto.RegisterType((*UpdateFolderShareReq)(nil), "api.UpdateFolderShareReq")
	proto.RegisterType((*UnshareFolderReq)(nil), "api.UnshareFolderReq")
	proto.RegisterType((*ListPublicLinksReq)(nil), "api.ListPublicLinksReq")
	proto.RegisterType((*ListFolderSharesReq)(nil), "api.ListFolderSharesReq")
	proto.RegisterType((*ReceivedShareReq)(nil), "api.ReceivedShareReq")
	proto.RegisterEnum("api.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("api.Tag_ItemType", Tag_ItemType_name, Tag_ItemType_value)
	proto.RegisterEnum("api.ShareRecipient_RecipientType", ShareRecipient_RecipientType_name, ShareRecipient_RecipientType_value)
	proto.RegisterEnum("api.PublicLink_ItemType", PublicLink_ItemType_name, PublicLink_ItemType_value)
	proto.RegisterEnum("api.FolderShare_State", FolderShare_State_name, FolderShare_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Auth service

type AuthClient interface {
	ForgeUserToken(ctx context.Context, in *ForgeUserTokenReq, opts ...grpc.CallOption) (*TokenResponse, error)
	DismantleUserToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*UserResponse, error)
	ForgePublicLinkToken(ctx context.Context, in *ForgePublicLinkTokenReq, opts ...grpc.CallOption) (*TokenResponse, error)
	DismantlePublicLinkToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) ForgeUserToken(ctx context.Context, in *ForgeUserTokenReq, opts ...grpc.CallOption) (*TokenResponse, error) {
	out := new(TokenResponse)
	err := grpc.Invoke(ctx, "/api.Auth/ForgeUserToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) DismantleUserToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := grpc.Invoke(ctx, "/api.Auth/DismantleUserToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) ForgePublicLinkToken(ctx context.Context, in *ForgePublicLinkTokenReq, opts ...grpc.CallOption) (*TokenResponse, error) {
	out := new(TokenResponse)
	err := grpc.Invoke(ctx, "/api.Auth/ForgePublicLinkToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) DismantlePublicLinkToken(ctx context.Context, in *TokenReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Auth/DismantlePublicLinkToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	ForgeUserToken(context.Context, *ForgeUserTokenReq) (*TokenResponse, error)
	DismantleUserToken(context.Context, *TokenReq) (*UserResponse, error)
	ForgePublicLinkToken(context.Context, *ForgePublicLinkTokenReq) (*TokenResponse, error)
	DismantlePublicLinkToken(context.Context, *TokenReq) (*PublicLinkResponse, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_ForgeUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgeUserTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).ForgeUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/ForgeUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).ForgeUserToken(ctx, req.(*ForgeUserTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_DismantleUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).DismantleUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/DismantleUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).DismantleUserToken(ctx, req.(*TokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_ForgePublicLinkToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgePublicLinkTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).ForgePublicLinkToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/ForgePublicLinkToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).ForgePublicLinkToken(ctx, req.(*ForgePublicLinkTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_DismantlePublicLinkToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).DismantlePublicLinkToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Auth/DismantlePublicLinkToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).DismantlePublicLinkToken(ctx, req.(*TokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ForgeUserToken",
			Handler:    _Auth_ForgeUserToken_Handler,
		},
		{
			MethodName: "DismantleUserToken",
			Handler:    _Auth_DismantleUserToken_Handler,
		},
		{
			MethodName: "ForgePublicLinkToken",
			Handler:    _Auth_ForgePublicLinkToken_Handler,
		},
		{
			MethodName: "DismantlePublicLinkToken",
			Handler:    _Auth_DismantlePublicLinkToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protocol.proto",
}

// Client API for Storage service

type StorageClient interface {
	CreateDir(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Delete(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Move(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	Inspect(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*MetadataResponse, error)
	ListFolder(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListFolderClient, error)
	StartWriteTx(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*TxInfoResponse, error)
	WriteChunk(ctx context.Context, opts ...grpc.CallOption) (Storage_WriteChunkClient, error)
	FinishWriteTx(ctx context.Context, in *TxEnd, opts ...grpc.CallOption) (*EmptyResponse, error)
	ReadFile(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ReadFileClient, error)
	ListRevisions(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRevisionsClient, error)
	ReadRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (Storage_ReadRevisionClient, error)
	RestoreRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRecycleClient, error)
	RestoreRecycleEntry(ctx context.Context, in *RecycleEntryReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	EmptyRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	SetACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	UpdateACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	UnsetACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	GetQuota(ctx context.Context, in *QuotaReq, opts ...grpc.CallOption) (*QuotaResponse, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) CreateDir(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/CreateDir", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Move(ctx context.Context, in *MoveReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Move", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Inspect(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*MetadataResponse, error) {
	out := new(MetadataResponse)
	err := grpc.Invoke(ctx, "/api.Storage/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ListFolder(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListFolderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[0], c.cc, "/api.Storage/ListFolder", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListFolderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListFolderClient interface {
	Recv() (*MetadataResponse, error)
	grpc.ClientStream
}

type storageListFolderClient struct {
	grpc.ClientStream
}

func (x *storageListFolderClient) Recv() (*MetadataResponse, error) {
	m := new(MetadataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) StartWriteTx(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (*TxInfoResponse, error) {
	out := new(TxInfoResponse)
	err := grpc.Invoke(ctx, "/api.Storage/StartWriteTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) WriteChunk(ctx context.Context, opts ...grpc.CallOption) (Storage_WriteChunkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[1], c.cc, "/api.Storage/WriteChunk", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageWriteChunkClient{stream}
	return x, nil
}

type Storage_WriteChunkClient interface {
	Send(*TxChunk) error
	CloseAndRecv() (*WriteSummaryResponse, error)
	grpc.ClientStream
}

type storageWriteChunkClient struct {
	grpc.ClientStream
}

func (x *storageWriteChunkClient) Send(m *TxChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storageWriteChunkClient) CloseAndRecv() (*WriteSummaryResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteSummaryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) FinishWriteTx(ctx context.Context, in *TxEnd, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/FinishWriteTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ReadFile(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ReadFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[2], c.cc, "/api.Storage/ReadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageReadFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ReadFileClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type storageReadFileClient struct {
	grpc.ClientStream
}

func (x *storageReadFileClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) ListRevisions(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRevisionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[3], c.cc, "/api.Storage/ListRevisions", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListRevisionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListRevisionsClient interface {
	Recv() (*RevisionResponse, error)
	grpc.ClientStream
}

type storageListRevisionsClient struct {
	grpc.ClientStream
}

func (x *storageListRevisionsClient) Recv() (*RevisionResponse, error) {
	m := new(RevisionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) ReadRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (Storage_ReadRevisionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[4], c.cc, "/api.Storage/ReadRevision", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageReadRevisionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ReadRevisionClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type storageReadRevisionClient struct {
	grpc.ClientStream
}

func (x *storageReadRevisionClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) RestoreRevision(ctx context.Context, in *RevisionReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/RestoreRevision", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ListRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Storage_ListRecycleClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Storage_serviceDesc.Streams[5], c.cc, "/api.Storage/ListRecycle", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageListRecycleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Storage_ListRecycleClient interface {
	Recv() (*RecycleEntryResponse, error)
	grpc.ClientStream
}

type storageListRecycleClient struct {
	grpc.ClientStream
}

func (x *storageListRecycleClient) Recv() (*RecycleEntryResponse, error) {
	m := new(RecycleEntryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storageClient) RestoreRecycleEntry(ctx context.Context, in *RecycleEntryReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/RestoreRecycleEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) EmptyRecycle(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/EmptyRecycle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) SetACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/SetACL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) UpdateACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/UpdateACL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) UnsetACL(ctx context.Context, in *ACLReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Storage/UnsetACL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) GetQuota(ctx context.Context, in *QuotaReq, opts ...grpc.CallOption) (*QuotaResponse, error) {
	out := new(QuotaResponse)
	err := grpc.Invoke(ctx, "/api.Storage/GetQuota", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Storage service

type StorageServer interface {
	CreateDir(context.Context, *PathReq) (*EmptyResponse, error)
	Delete(context.Context, *PathReq) (*EmptyResponse, error)
	Move(context.Context, *MoveReq) (*EmptyResponse, error)
	Inspect(context.Context, *PathReq) (*MetadataResponse, error)
	ListFolder(*PathReq, Storage_ListFolderServer) error
	StartWriteTx(context.Context, *EmptyReq) (*TxInfoResponse, error)
	WriteChunk(Storage_WriteChunkServer) error
	FinishWriteTx(context.Context, *TxEnd) (*EmptyResponse, error)
	ReadFile(*PathReq, Storage_ReadFileServer) error
	ListRevisions(*PathReq, Storage_ListRevisionsServer) error
	ReadRevision(*RevisionReq, Storage_ReadRevisionServer) error
	RestoreRevision(context.Context, *RevisionReq) (*EmptyResponse, error)
	ListRecycle(*PathReq, Storage_ListRecycleServer) error
	RestoreRecycleEntry(context.Context, *RecycleEntryReq) (*EmptyResponse, error)
	EmptyRecycle(context.Context, *PathReq) (*EmptyResponse, error)
	SetACL(context.Context, *ACLReq) (*EmptyResponse, error)
	UpdateACL(context.Context, *ACLReq) (*EmptyResponse, error)
	UnsetACL(context.Context, *ACLReq) (*EmptyResponse, error)
	GetQuota(context.Context, *QuotaReq) (*QuotaResponse, error)
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_CreateDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).CreateDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/CreateDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).CreateDir(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Delete(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Move(ctx, req.(*MoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).Inspect(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ListFolder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListFolder(m, &storageListFolderServer{stream})
}

type Storage_ListFolderServer interface {
	Send(*MetadataResponse) error
	grpc.ServerStream
}

type storageListFolderServer struct {
	grpc.ServerStream
}

func (x *storageListFolderServer) Send(m *MetadataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_StartWriteTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).StartWriteTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/StartWriteTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).StartWriteTx(ctx, req.(*EmptyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_WriteChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServer).WriteChunk(&storageWriteChunkServer{stream})
}

type Storage_WriteChunkServer interface {
	SendAndClose(*WriteSummaryResponse) error
	Recv() (*TxChunk, error)
	grpc.ServerStream
}

type storageWriteChunkServer struct {
	grpc.ServerStream
}

func (x *storageWriteChunkServer) SendAndClose(m *WriteSummaryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storageWriteChunkServer) Recv() (*TxChunk, error) {
	m := new(TxChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Storage_FinishWriteTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxEnd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).FinishWriteTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/FinishWriteTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).FinishWriteTx(ctx, req.(*TxEnd))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ReadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ReadFile(m, &storageReadFileServer{stream})
}

type Storage_ReadFileServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type storageReadFileServer struct {
	grpc.ServerStream
}

func (x *storageReadFileServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_ListRevisions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListRevisions(m, &storageListRevisionsServer{stream})
}

type Storage_ListRevisionsServer interface {
	Send(*RevisionResponse) error
	grpc.ServerStream
}

type storageListRevisionsServer struct {
	grpc.ServerStream
}

func (x *storageListRevisionsServer) Send(m *RevisionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_ReadRevision_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RevisionReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ReadRevision(m, &storageReadRevisionServer{stream})
}

type Storage_ReadRevisionServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type storageReadRevisionServer struct {
	grpc.ServerStream
}

func (x *storageReadRevisionServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_RestoreRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevisionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).RestoreRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/RestoreRevision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).RestoreRevision(ctx, req.(*RevisionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ListRecycle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServer).ListRecycle(m, &storageListRecycleServer{stream})
}

type Storage_ListRecycleServer interface {
	Send(*RecycleEntryResponse) error
	grpc.ServerStream
}

type storageListRecycleServer struct {
	grpc.ServerStream
}

func (x *storageListRecycleServer) Send(m *RecycleEntryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Storage_RestoreRecycleEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecycleEntryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).RestoreRecycleEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/RestoreRecycleEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).RestoreRecycleEntry(ctx, req.(*RecycleEntryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_EmptyRecycle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).EmptyRecycle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/EmptyRecycle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).EmptyRecycle(ctx, req.(*PathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_SetACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).SetACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/SetACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).SetACL(ctx, req.(*ACLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_UpdateACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).UpdateACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/UpdateACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).UpdateACL(ctx, req.(*ACLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_UnsetACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).UnsetACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/UnsetACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).UnsetACL(ctx, req.(*ACLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_GetQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuotaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).GetQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Storage/GetQuota",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).GetQuota(ctx, req.(*QuotaReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDir",
			Handler:    _Storage_CreateDir_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Storage_Move_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _Storage_Inspect_Handler,
		},
		{
			MethodName: "StartWriteTx",
			Handler:    _Storage_StartWriteTx_Handler,
		},
		{
			MethodName: "FinishWriteTx",
			Handler:    _Storage_FinishWriteTx_Handler,
		},
		{
			MethodName: "RestoreRevision",
			Handler:    _Storage_RestoreRevision_Handler,
		},
		{
			MethodName: "RestoreRecycleEntry",
			Handler:    _Storage_RestoreRecycleEntry_Handler,
		},
		{
			MethodName: "EmptyRecycle",
			Handler:    _Storage_EmptyRecycle_Handler,
		},
		{
			MethodName: "SetACL",
			Handler:    _Storage_SetACL_Handler,
		},
		{
			MethodName: "UpdateACL",
			Handler:    _Storage_UpdateACL_Handler,
		},
		{
			MethodName: "UnsetACL",
			Handler:    _Storage_UnsetACL_Handler,
		},
		{
			MethodName: "GetQuota",
			Handler:    _Storage_GetQuota_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListFolder",
			Handler:       _Storage_ListFolder_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteChunk",
			Handler:       _Storage_WriteChunk_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadFile",
			Handler:       _Storage_ReadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListRevisions",
			Handler:       _Storage_ListRevisions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReadRevision",
			Handler:       _Storage_ReadRevision_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListRecycle",
			Handler:       _Storage_ListRecycle_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocol.proto",
}

// Client API for Tagger service

type TaggerClient interface {
	GetTags(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (Tagger_GetTagsClient, error)
	SetTag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	UnSetTag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type taggerClient struct {
	cc *grpc.ClientConn
}

func NewTaggerClient(cc *grpc.ClientConn) TaggerClient {
	return &taggerClient{cc}
}

func (c *taggerClient) GetTags(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (Tagger_GetTagsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Tagger_serviceDesc.Streams[0], c.cc, "/api.Tagger/GetTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &taggerGetTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tagger_GetTagsClient interface {
	Recv() (*TagResponse, error)
	grpc.ClientStream
}

type taggerGetTagsClient struct {
	grpc.ClientStream
}

func (x *taggerGetTagsClient) Recv() (*TagResponse, error) {
	m := new(TagResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *taggerClient) SetTag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Tagger/SetTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taggerClient) UnSetTag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Tagger/UnSetTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Tagger service

type TaggerServer interface {
	GetTags(*TagReq, Tagger_GetTagsServer) error
	SetTag(context.Context, *TagReq) (*EmptyResponse, error)
	UnSetTag(context.Context, *TagReq) (*EmptyResponse, error)
}

func RegisterTaggerServer(s *grpc.Server, srv TaggerServer) {
	s.RegisterService(&_Tagger_serviceDesc, srv)
}

func _Tagger_GetTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TaggerServer).GetTags(m, &taggerGetTagsServer{stream})
}

type Tagger_GetTagsServer interface {
	Send(*TagResponse) error
	grpc.ServerStream
}

type taggerGetTagsServer struct {
	grpc.ServerStream
}

func (x *taggerGetTagsServer) Send(m *TagResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Tagger_SetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaggerServer).SetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Tagger/SetTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaggerServer).SetTag(ctx, req.(*TagReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tagger_UnSetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaggerServer).UnSetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Tagger/UnSetTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaggerServer).UnSetTag(ctx, req.(*TagReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tagger_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Tagger",
	HandlerType: (*TaggerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetTag",
			Handler:    _Tagger_SetTag_Handler,
		},
		{
			MethodName: "UnSetTag",
			Handler:    _Tagger_UnSetTag_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTags",
			Handler:       _Tagger_GetTags_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocol.proto",
}

// Client API for Share service

type ShareClient interface {
	// with user context, relative to the user logged in
	CreatePublicLink(ctx context.Context, in *NewLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	UpdatePublicLink(ctx context.Context, in *UpdateLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	InspectPublicLink(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*PublicLinkResponse, error)
	RevokePublicLink(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	ListPublicLinks(ctx context.Context, in *ListPublicLinksReq, opts ...grpc.CallOption) (Share_ListPublicLinksClient, error)
	// with user context, relative to user logged in
	AddFolderShare(ctx context.Context, in *NewFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error)
	UpdateFolderShare(ctx context.Context, in *UpdateFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error)
	ListFolderShares(ctx context.Context, in *ListFolderSharesReq, opts ...grpc.CallOption) (Share_ListFolderSharesClient, error)
	UnshareFolder(ctx context.Context, in *UnshareFolderReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	GetFolderShare(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*FolderShareResponse, error)
	// with user context, relative to the user logged in, in this case, the receiver
	ListReceivedShares(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListReceivedSharesClient, error)
	MountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error)
	UnmountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error)
}

type shareClient struct {
	cc *grpc.ClientConn
}

func NewShareClient(cc *grpc.ClientConn) ShareClient {
	return &shareClient{cc}
}

func (c *shareClient) CreatePublicLink(ctx context.Context, in *NewLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/CreatePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdatePublicLink(ctx context.Context, in *UpdateLinkReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/UpdatePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) InspectPublicLink(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*PublicLinkResponse, error) {
	out := new(PublicLinkResponse)
	err := grpc.Invoke(ctx, "/api.Share/InspectPublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) RevokePublicLink(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/RevokePublicLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListPublicLinks(ctx context.Context, in *ListPublicLinksReq, opts ...grpc.CallOption) (Share_ListPublicLinksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[0], c.cc, "/api.Share/ListPublicLinks", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListPublicLinksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListPublicLinksClient interface {
	Recv() (*PublicLinkResponse, error)
	grpc.ClientStream
}

type shareListPublicLinksClient struct {
	grpc.ClientStream
}

func (x *shareListPublicLinksClient) Recv() (*PublicLinkResponse, error) {
	m := new(PublicLinkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) AddFolderShare(ctx context.Context, in *NewFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error) {
	out := new(FolderShareResponse)
	err := grpc.Invoke(ctx, "/api.Share/AddFolderShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UpdateFolderShare(ctx context.Context, in *UpdateFolderShareReq, opts ...grpc.CallOption) (*FolderShareResponse, error) {
	out := new(FolderShareResponse)
	err := grpc.Invoke(ctx, "/api.Share/UpdateFolderShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListFolderShares(ctx context.Context, in *ListFolderSharesReq, opts ...grpc.CallOption) (Share_ListFolderSharesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[1], c.cc, "/api.Share/ListFolderShares", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListFolderSharesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListFolderSharesClient interface {
	Recv() (*FolderShareResponse, error)
	grpc.ClientStream
}

type shareListFolderSharesClient struct {
	grpc.ClientStream
}

func (x *shareListFolderSharesClient) Recv() (*FolderShareResponse, error) {
	m := new(FolderShareResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) UnshareFolder(ctx context.Context, in *UnshareFolderReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/UnshareFolder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) GetFolderShare(ctx context.Context, in *ShareIDReq, opts ...grpc.CallOption) (*FolderShareResponse, error) {
	out := new(FolderShareResponse)
	err := grpc.Invoke(ctx, "/api.Share/GetFolderShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) ListReceivedShares(ctx context.Context, in *EmptyReq, opts ...grpc.CallOption) (Share_ListReceivedSharesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Share_serviceDesc.Streams[2], c.cc, "/api.Share/ListReceivedShares", opts...)
	if err != nil {
		return nil, err
	}
	x := &shareListReceivedSharesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Share_ListReceivedSharesClient interface {
	Recv() (*ReceivedShareResponse, error)
	grpc.ClientStream
}

type shareListReceivedSharesClient struct {
	grpc.ClientStream
}

func (x *shareListReceivedSharesClient) Recv() (*ReceivedShareResponse, error) {
	m := new(ReceivedShareResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shareClient) MountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/MountReceivedShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shareClient) UnmountReceivedShare(ctx context.Context, in *ReceivedShareReq, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/api.Share/UnmountReceivedShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Share service

type ShareServer interface {
	// with user context, relative to the user logged in
	CreatePublicLink(context.Context, *NewLinkReq) (*PublicLinkResponse, error)
	UpdatePublicLink(context.Context, *UpdateLinkReq) (*PublicLinkResponse, error)
	InspectPublicLink(context.Context, *ShareIDReq) (*PublicLinkResponse, error)
	RevokePublicLink(context.Context, *ShareIDReq) (*EmptyResponse, error)
	ListPublicLinks(*ListPublicLinksReq, Share_ListPublicLinksServer) error
	// with user context, relative to user logged in
	AddFolderShare(context.Context, *NewFolderShareReq) (*FolderShareResponse, error)
	UpdateFolderShare(context.Context, *UpdateFolderShareReq) (*FolderShareResponse, error)
	ListFolderShares(*ListFolderSharesReq, Share_ListFolderSharesServer) error
	UnshareFolder(context.Context, *UnshareFolderReq) (*EmptyResponse, error)
	GetFolderShare(context.Context, *ShareIDReq) (*FolderShareResponse, error)
	// with user context, relative to the user logged in, in this case, the receiver
	ListReceivedShares(*EmptyReq, Share_ListReceivedSharesServer) error
	MountReceivedShare(context.Context, *ReceivedShareReq) (*EmptyResponse, error)
	UnmountReceivedShare(context.Context, *ReceivedShareReq) (*EmptyResponse, error)
}

func RegisterShareServer(s *grpc.Server, srv ShareServer) {
	s.RegisterService(&_Share_serviceDesc, srv)
}

func _Share_CreatePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewLinkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).CreatePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/CreatePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).CreatePublicLink(ctx, req.(*NewLinkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdatePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLinkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdatePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UpdatePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdatePublicLink(ctx, req.(*UpdateLinkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_InspectPublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).InspectPublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/InspectPublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).InspectPublicLink(ctx, req.(*ShareIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_RevokePublicLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).RevokePublicLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/RevokePublicLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).RevokePublicLink(ctx, req.(*ShareIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListPublicLinks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPublicLinksReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListPublicLinks(m, &shareListPublicLinksServer{stream})
}

type Share_ListPublicLinksServer interface {
	Send(*PublicLinkResponse) error
	grpc.ServerStream
}

type shareListPublicLinksServer struct {
	grpc.ServerStream
}

func (x *shareListPublicLinksServer) Send(m *PublicLinkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_AddFolderShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewFolderShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).AddFolderShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/AddFolderShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).AddFolderShare(ctx, req.(*NewFolderShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UpdateFolderShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFolderShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UpdateFolderShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UpdateFolderShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UpdateFolderShare(ctx, req.(*UpdateFolderShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListFolderShares_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFolderSharesReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListFolderShares(m, &shareListFolderSharesServer{stream})
}

type Share_ListFolderSharesServer interface {
	Send(*FolderShareResponse) error
	grpc.ServerStream
}

type shareListFolderSharesServer struct {
	grpc.ServerStream
}

func (x *shareListFolderSharesServer) Send(m *FolderShareResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_UnshareFolder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnshareFolderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UnshareFolder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UnshareFolder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UnshareFolder(ctx, req.(*UnshareFolderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_GetFolderShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).GetFolderShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/GetFolderShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).GetFolderShare(ctx, req.(*ShareIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_ListReceivedShares_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EmptyReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShareServer).ListReceivedShares(m, &shareListReceivedSharesServer{stream})
}

type Share_ListReceivedSharesServer interface {
	Send(*ReceivedShareResponse) error
	grpc.ServerStream
}

type shareListReceivedSharesServer struct {
	grpc.ServerStream
}

func (x *shareListReceivedSharesServer) Send(m *ReceivedShareResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Share_MountReceivedShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).MountReceivedShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/MountReceivedShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).MountReceivedShare(ctx, req.(*ReceivedShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Share_UnmountReceivedShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedShareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShareServer).UnmountReceivedShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Share/UnmountReceivedShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShareServer).UnmountReceivedShare(ctx, req.(*ReceivedShareReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Share_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Share",
	HandlerType: (*ShareServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePublicLink",
			Handler:    _Share_CreatePublicLink_Handler,
		},
		{
			MethodName: "UpdatePublicLink",
			Handler:    _Share_UpdatePublicLink_Handler,
		},
		{
			MethodName: "InspectPublicLink",
			Handler:    _Share_InspectPublicLink_Handler,
		},
		{
			MethodName: "RevokePublicLink",
			Handler:    _Share_RevokePublicLink_Handler,
		},
		{
			MethodName: "AddFolderShare",
			Handler:    _Share_AddFolderShare_Handler,
		},
		{
			MethodName: "UpdateFolderShare",
			Handler:    _Share_UpdateFolderShare_Handler,
		},
		{
			MethodName: "UnshareFolder",
			Handler:    _Share_UnshareFolder_Handler,
		},
		{
			MethodName: "GetFolderShare",
			Handler:    _Share_GetFolderShare_Handler,
		},
		{
			MethodName: "MountReceivedShare",
			Handler:    _Share_MountReceivedShare_Handler,
		},
		{
			MethodName: "UnmountReceivedShare",
			Handler:    _Share_UnmountReceivedShare_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListPublicLinks",
			Handler:       _Share_ListPublicLinks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFolderShares",
			Handler:       _Share_ListFolderShares_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListReceivedShares",
			Handler:       _Share_ListReceivedShares_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocol.proto",
}

// Client API for Preview service

type PreviewClient interface {
	ReadPreview(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Preview_ReadPreviewClient, error)
}

type previewClient struct {
	cc *grpc.ClientConn
}

func NewPreviewClient(cc *grpc.ClientConn) PreviewClient {
	return &previewClient{cc}
}

func (c *previewClient) ReadPreview(ctx context.Context, in *PathReq, opts ...grpc.CallOption) (Preview_ReadPreviewClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Preview_serviceDesc.Streams[0], c.cc, "/api.Preview/ReadPreview", opts...)
	if err != nil {
		return nil, err
	}
	x := &previewReadPreviewClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Preview_ReadPreviewClient interface {
	Recv() (*DataChunkResponse, error)
	grpc.ClientStream
}

type previewReadPreviewClient struct {
	grpc.ClientStream
}

func (x *previewReadPreviewClient) Recv() (*DataChunkResponse, error) {
	m := new(DataChunkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Preview service

type PreviewServer interface {
	ReadPreview(*PathReq, Preview_ReadPreviewServer) error
}

func RegisterPreviewServer(s *grpc.Server, srv PreviewServer) {
	s.RegisterService(&_Preview_serviceDesc, srv)
}

func _Preview_ReadPreview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PreviewServer).ReadPreview(m, &previewReadPreviewServer{stream})
}

type Preview_ReadPreviewServer interface {
	Send(*DataChunkResponse) error
	grpc.ServerStream
}

type previewReadPreviewServer struct {
	grpc.ServerStream
}

func (x *previewReadPreviewServer) Send(m *DataChunkResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Preview_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Preview",
	HandlerType: (*PreviewServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadPreview",
			Handler:       _Preview_ReadPreview_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocol.proto",
}

func init() { proto.RegisterFile("protocol.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x1a, 0xdb, 0x72, 0xdb, 0xc6,
	0xd5, 0xbc, 0x83, 0x87, 0x17, 0x43, 0x6b, 0xd9, 0xa1, 0x64, 0x3b, 0x71, 0x90, 0x4e, 0xe3, 0x24,
	0x8e, 0xe2, 0xb0, 0xf1, 0x34, 0x49, 0xdb, 0x64, 0x18, 0x92, 0x52, 0x18, 0x4b, 0x24, 0x03, 0x92,
	0x4e, 0xfa, 0xd0, 0xa2, 0x30, 0xb1, 0xa2, 0xb6, 0x22, 0x01, 0x1a, 0x58, 0xea, 0x92, 0xcf, 0x48,
	0x67, 0xfa, 0xd0, 0x3f, 0xe9, 0x5b, 0x3f, 0xa3, 0x33, 0xfd, 0x87, 0xbe, 0xb6, 0xd3, 0xa7, 0xce,
	0x5e, 0x40, 0x2e, 0x48, 0x90, 0x11, 0xdd, 0x99, 0x3e, 0x09, 0x7b, 0xf6, 0xec, 0xb9, 0xed, 0xb9,
	0x2e, 0x05, 0xe5, 0xa9, 0xef, 0x51, 0x6f, 0xe8, 0x8d, 0x0f, 0xf8, 0x07, 0x4a, 0xd9, 0x53, 0x62,
	0xb4, 0x21, 0xdb, 0xb7, 0x47, 0x26, 0x7e, 0x85, 0xde, 0x80, 0x1c, 0xb5, 0x47, 0xd6, 0x39, 0xbe,
	0xae, 0x24, 0x1e, 0x25, 0x1e, 0xe7, 0xcd, 0x2c, 0xb5, 0x47, 0xcf, 0xf1, 0x75, 0xb8, 0x71, 0x61,
	0x8f, 0x2b, 0xc9, 0xf9, 0xc6, 0x0b, 0x7b, 0x8c, 0x10, 0xa4, 0xa7, 0x36, 0x3d, 0xab, 0xa4, 0x38,
	0x94, 0x7f, 0x1b, 0xff, 0x4c, 0x40, 0xaa, 0x6f, 0x8f, 0x50, 0x19, 0x92, 0xc4, 0xe1, 0x84, 0x52,
	0x66, 0x92, 0x38, 0xe8, 0x00, 0xf2, 0x84, 0xe2, 0x89, 0x45, 0xaf, 0xa7, 0x98, 0x93, 0x29, 0x57,
	0x77, 0x0e, 0xec, 0x29, 0x39, 0xe8, 0xdb, 0xa3, 0x83, 0x16, 0xc5, 0x93, 0xfe, 0xf5, 0x14, 0x9b,
	0x1a, 0x91, 0x5f, 0x48, 0x87, 0xd4, 0x8c, 0x38, 0x92, 0x34, 0xfb, 0x44, 0x3f, 0x83, 0xf2, 0x29,
	0x19, 0x63, 0x8b, 0x38, 0xd6, 0xd4, 0xc7, 0xa7, 0xe4, 0xaa, 0x92, 0xe6, 0x9b, 0x45, 0x06, 0x6d,
	0x39, 0x5d, 0x0e, 0x63, 0xc2, 0x4a, 0xac, 0x4a, 0x46, 0x08, 0x2b, 0xb6, 0x55, 0xf5, 0xb2, 0x11,
	0xf5, 0xee, 0x43, 0x5e, 0xaa, 0x37, 0xc3, 0x95, 0x1c, 0xdf, 0xd2, 0x84, 0x82, 0x33, 0x6c, 0x3c,
	0x02, 0x2d, 0x14, 0x0e, 0x01, 0x64, 0x0f, 0x3b, 0xc7, 0x8d, 0xa6, 0xa9, 0xdf, 0x42, 0x1a, 0xa4,
	0x0f, 0x5b, 0xc7, 0x4d, 0x3d, 0x61, 0x98, 0x50, 0xe0, 0x06, 0x0c, 0xa6, 0x9e, 0x1b, 0x60, 0xf4,
	0x2e, 0x64, 0x03, 0x6a, 0xd3, 0x59, 0xc0, 0x75, 0x2f, 0x57, 0x6f, 0x73, 0x25, 0x7b, 0x1c, 0x54,
	0xf7, 0x1c, 0x6c, 0xca, 0x6d, 0xb4, 0x0f, 0x29, 0x6a, 0x8f, 0xb8, 0x29, 0x0a, 0x55, 0x2d, 0x34,
	0x85, 0xc9, 0x80, 0xc6, 0x29, 0x3c, 0x6c, 0x05, 0xdd, 0xd9, 0xcb, 0x31, 0x19, 0x1e, 0x13, 0xf7,
	0xbc, 0xeb, 0x7b, 0x14, 0x0f, 0x29, 0x76, 0xb6, 0xe7, 0xf2, 0x00, 0xf2, 0xd3, 0xf0, 0x34, 0xe7,
	0xa5, 0x99, 0x0b, 0x80, 0xf1, 0x1c, 0xde, 0x38, 0xf4, 0xfc, 0x11, 0x5e, 0xb0, 0xea, 0x7b, 0xe7,
	0xd8, 0x65, 0xde, 0xb0, 0x0b, 0x19, 0xca, 0xbe, 0xa5, 0x2f, 0x88, 0x05, 0xda, 0x07, 0x6d, 0x6a,
	0x07, 0xc1, 0xa5, 0xe7, 0x3b, 0xd2, 0x17, 0xe6, 0x6b, 0xe3, 0x77, 0xf0, 0x20, 0x9e, 0xd8, 0xb6,
	0x32, 0xef, 0x42, 0xe6, 0xc2, 0x1e, 0x93, 0x50, 0x5e, 0xb1, 0x30, 0x9e, 0x42, 0xe5, 0x05, 0xf6,
	0xc9, 0xe9, 0xf5, 0x4d, 0x85, 0x35, 0x7e, 0x80, 0x87, 0x6b, 0x4e, 0x6c, 0x2b, 0xd1, 0x53, 0x28,
	0x4c, 0x39, 0x0d, 0x6b, 0x4c, 0xdc, 0x73, 0x79, 0x67, 0x02, 0x7b, 0x41, 0xdb, 0x84, 0xe9, 0xfc,
	0xdb, 0xf8, 0x14, 0x4a, 0xcd, 0xc9, 0x94, 0x5e, 0x6f, 0xcd, 0xcb, 0x00, 0xd0, 0xe4, 0xc9, 0x57,
	0xc6, 0x9b, 0xa0, 0x7d, 0x3b, 0xf3, 0xa8, 0xcd, 0x74, 0x0c, 0x83, 0x2d, 0xa1, 0x04, 0xdb, 0x15,
	0x94, 0xe4, 0xfe, 0xb6, 0x1a, 0xbd, 0x05, 0x05, 0xea, 0x51, 0x7b, 0x6c, 0xbd, 0xbc, 0xa6, 0x38,
	0xe0, 0x1a, 0xa5, 0x4c, 0xe0, 0xa0, 0xaf, 0x18, 0x04, 0x3d, 0x04, 0x98, 0x05, 0xd8, 0x91, 0xfb,
	0x29, 0xbe, 0x9f, 0x67, 0x10, 0xbe, 0x6d, 0xbc, 0x80, 0xe2, 0x20, 0xc0, 0xfe, 0xf6, 0x8c, 0x1f,
	0x42, 0x7a, 0x16, 0x60, 0x5f, 0xda, 0x30, 0xcf, 0xd1, 0x38, 0x25, 0x0e, 0x36, 0xfe, 0x00, 0x69,
	0xb6, 0x62, 0xec, 0xed, 0xe1, 0xd0, 0x9b, 0xb9, 0xd4, 0x92, 0x69, 0x24, 0x6f, 0xe6, 0x25, 0xa4,
	0xe5, 0xa0, 0x7b, 0x90, 0x1d, 0xf9, 0xde, 0x6c, 0xca, 0x24, 0x4f, 0xb1, 0x58, 0x16, 0x2b, 0xf4,
	0x36, 0x14, 0x1d, 0x12, 0x4c, 0xc7, 0xf6, 0xb5, 0xe5, 0xda, 0x13, 0x2c, 0xd3, 0x47, 0x41, 0xc2,
	0xda, 0xf6, 0x04, 0x1b, 0xbf, 0x87, 0x72, 0xff, 0xaa, 0xe5, 0x9e, 0x7a, 0xdb, 0xcb, 0xfe, 0x0e,
	0x64, 0x29, 0x3f, 0x2a, 0xa5, 0x2f, 0x88, 0xa8, 0x15, 0xd4, 0xe4, 0x96, 0xf1, 0x10, 0xb2, 0x02,
	0x82, 0xee, 0x40, 0x86, 0x5e, 0x2d, 0xc4, 0x4f, 0xd3, 0xab, 0x96, 0x63, 0x0c, 0x60, 0x87, 0x47,
	0x09, 0xd3, 0x72, 0xee, 0xbf, 0xf7, 0x21, 0x3f, 0x1c, 0x13, 0xac, 0x2a, 0xab, 0x09, 0x40, 0xcb,
	0x41, 0xef, 0x40, 0x49, 0x6e, 0x06, 0x78, 0xe8, 0x63, 0x2a, 0x03, 0xaf, 0x28, 0x80, 0x3d, 0x0e,
	0x33, 0xda, 0x50, 0x7a, 0xfd, 0x68, 0x13, 0xb1, 0x93, 0x54, 0x63, 0xe7, 0x11, 0x68, 0x3f, 0x11,
	0x5d, 0xa7, 0xa0, 0x9f, 0x60, 0x6a, 0x3b, 0xf6, 0xeb, 0xb8, 0xdf, 0x7b, 0xa0, 0x4d, 0xe4, 0x61,
	0x69, 0xcb, 0x12, 0x47, 0x9d, 0x53, 0x9c, 0x6f, 0x1b, 0xff, 0x48, 0x81, 0x16, 0x82, 0x95, 0xaa,
	0x92, 0xe7, 0x55, 0x25, 0x0c, 0x8a, 0xe4, 0x22, 0x28, 0x18, 0x2c, 0x20, 0x3f, 0x88, 0xbb, 0x4f,
	0x9b, 0xfc, 0x9b, 0xa9, 0x30, 0xa1, 0x64, 0x82, 0x79, 0xc9, 0x48, 0x9b, 0x62, 0x81, 0xee, 0x42,
	0x96, 0x04, 0x96, 0x43, 0x7c, 0x5e, 0x2a, 0x34, 0x33, 0x43, 0x82, 0x06, 0xf1, 0x19, 0x01, 0xcc,
	0x52, 0xb3, 0x28, 0x13, 0xfc, 0x9b, 0x25, 0xbe, 0xe1, 0x19, 0x1e, 0x9e, 0x07, 0xb3, 0x49, 0x58,
	0x23, 0xc2, 0x35, 0xf3, 0x55, 0x07, 0xfb, 0xf8, 0xd4, 0xe2, 0xa2, 0x68, 0xc2, 0x57, 0x39, 0xa4,
	0xcb, 0xe4, 0x79, 0x04, 0x45, 0x12, 0x58, 0x3e, 0xb6, 0x1d, 0xcb, 0x73, 0xc7, 0xd7, 0x95, 0x3c,
	0xe7, 0x05, 0x24, 0x30, 0xb1, 0xed, 0x74, 0xdc, 0xf1, 0x35, 0xf3, 0x5a, 0x12, 0x58, 0xc1, 0x99,
	0xed, 0x63, 0xfb, 0xe5, 0x18, 0x57, 0x80, 0x63, 0x14, 0x48, 0xd0, 0x0b, 0x41, 0x4c, 0xa6, 0x09,
	0x93, 0xbf, 0x20, 0x64, 0x62, 0xdf, 0xac, 0x44, 0x06, 0xd7, 0x41, 0xa5, 0xf8, 0x28, 0xf1, 0xb8,
	0x68, 0xb2, 0x4f, 0x26, 0x09, 0xf5, 0x31, 0xb6, 0x78, 0x98, 0x54, 0x4a, 0x5c, 0xd7, 0x3c, 0x83,
	0xd4, 0x19, 0x00, 0xed, 0x81, 0x86, 0xbd, 0xc0, 0x62, 0x05, 0xb1, 0x52, 0xe6, 0x84, 0x72, 0xd8,
	0x0b, 0x0e, 0xc9, 0x18, 0x33, 0x11, 0xd8, 0x16, 0x71, 0x03, 0x6a, 0xbb, 0x43, 0x5c, 0xb9, 0x2d,
	0x02, 0x07, 0x7b, 0x41, 0x4b, 0x82, 0x18, 0x0a, 0x17, 0xd1, 0xa2, 0xb6, 0x3f, 0xc2, 0xb4, 0xa2,
	0x0b, 0x14, 0x0e, 0xeb, 0x73, 0x10, 0x33, 0xe8, 0x84, 0x8c, 0x98, 0x13, 0xef, 0x08, 0x57, 0x99,
	0x90, 0x51, 0xcb, 0x61, 0x7c, 0x19, 0x98, 0x9b, 0x07, 0x09, 0xbe, 0x13, 0x32, 0x62, 0xc6, 0x31,
	0x1e, 0x42, 0x8e, 0xfd, 0x5d, 0x97, 0xe0, 0xbe, 0x84, 0xdc, 0x89, 0x77, 0x81, 0xd9, 0xf6, 0x1e,
	0x68, 0xde, 0xd8, 0xb1, 0x14, 0x94, 0x9c, 0x37, 0x76, 0xb8, 0x85, 0xf7, 0x40, 0x73, 0xf1, 0xa5,
	0xa5, 0x78, 0x42, 0xce, 0xc5, 0x97, 0x9c, 0xfe, 0x4b, 0xc8, 0xf5, 0xaf, 0xea, 0x67, 0x33, 0xf7,
	0x3c, 0x36, 0x1c, 0x59, 0x22, 0x19, 0x63, 0x77, 0x24, 0x0f, 0xa6, 0x4d, 0xb9, 0x62, 0x70, 0xef,
	0xf4, 0x34, 0xc0, 0x54, 0xba, 0x91, 0x5c, 0x31, 0x21, 0xb9, 0xd3, 0xa6, 0xb9, 0xd1, 0xf9, 0xb7,
	0x71, 0x01, 0xbb, 0xdf, 0xf9, 0x84, 0xe2, 0xde, 0x6c, 0x32, 0xb1, 0xfd, 0xed, 0x53, 0x3e, 0x7a,
	0x06, 0xc5, 0x4b, 0x85, 0x80, 0x8c, 0x08, 0xd1, 0x1e, 0x45, 0x28, 0x47, 0xd0, 0x8c, 0x23, 0x28,
	0xaa, 0xbb, 0xa8, 0x02, 0x39, 0x77, 0xc8, 0x54, 0x15, 0x0c, 0xd3, 0x66, 0xb8, 0xe4, 0x7e, 0xc1,
	0xb3, 0x3d, 0x0f, 0x8c, 0xa4, 0xf4, 0x0b, 0x06, 0xe9, 0x91, 0x1f, 0xb0, 0x71, 0x0c, 0x99, 0xfe,
	0x55, 0xd3, 0x75, 0xe2, 0x4d, 0x14, 0x17, 0x63, 0x6a, 0x38, 0xa4, 0xa2, 0xe1, 0x60, 0xfc, 0x11,
	0x76, 0x1a, 0x36, 0xb5, 0xb9, 0xd1, 0xb7, 0xb7, 0xc5, 0x13, 0xc8, 0x3b, 0xe1, 0x69, 0x69, 0x88,
	0x32, 0xc7, 0x5d, 0xd0, 0x5c, 0x20, 0x18, 0x1d, 0xc8, 0xcf, 0xe1, 0xca, 0x5d, 0x26, 0xd6, 0xdc,
	0x65, 0x32, 0xf6, 0x2e, 0x53, 0xca, 0x5d, 0x9e, 0x82, 0x6e, 0xe2, 0x0b, 0x12, 0x10, 0xcf, 0x7d,
	0xad, 0xac, 0xe6, 0xcb, 0xc3, 0x91, 0xac, 0x36, 0xa7, 0x38, 0xdf, 0x36, 0x1c, 0xd0, 0x42, 0x28,
	0xeb, 0x4c, 0x7d, 0x7c, 0xa1, 0x36, 0xde, 0x3e, 0xbe, 0x60, 0x9d, 0x69, 0x98, 0xc9, 0x92, 0x71,
	0x99, 0x2c, 0x15, 0x9f, 0xc9, 0xd2, 0x4a, 0x26, 0x33, 0x3e, 0x87, 0xc2, 0x42, 0x9b, 0xd8, 0x08,
	0x53, 0x99, 0x27, 0x55, 0xe6, 0xcc, 0xab, 0x4d, 0x3c, 0xbc, 0x1e, 0x8e, 0x71, 0xd3, 0xa5, 0xaf,
	0xe9, 0xd5, 0xbe, 0x42, 0x20, 0xe2, 0xd5, 0x11, 0xca, 0x11, 0x34, 0xe3, 0x2f, 0x09, 0x28, 0xaa,
	0xdb, 0x2c, 0xef, 0xf8, 0x38, 0xa0, 0x9e, 0x8f, 0xd5, 0xe0, 0x2f, 0x48, 0x18, 0x4f, 0x00, 0x6f,
	0x41, 0xb8, 0x54, 0x14, 0x01, 0x09, 0x52, 0x2d, 0xa9, 0xd6, 0x84, 0xfb, 0x90, 0x77, 0xf0, 0xd8,
	0x52, 0xeb, 0x82, 0xe6, 0xe0, 0xf1, 0xc9, 0x86, 0xd2, 0x60, 0x54, 0xe1, 0x76, 0xd4, 0x28, 0xaf,
	0x96, 0x79, 0x27, 0x96, 0x79, 0x1b, 0xbf, 0x82, 0xdb, 0xbc, 0x89, 0xc7, 0xfe, 0x84, 0x04, 0xec,
	0x2a, 0x02, 0x26, 0x0e, 0xab, 0x07, 0x1c, 0x59, 0x33, 0xf9, 0x37, 0xbb, 0x58, 0x1e, 0xdd, 0x61,
	0xd7, 0xcb, 0x17, 0x46, 0x00, 0xd0, 0xc6, 0x97, 0xbc, 0xbd, 0x5c, 0x73, 0x81, 0xf7, 0x21, 0xbf,
	0xa8, 0x2d, 0xe2, 0xac, 0xe6, 0x87, 0x95, 0x45, 0xed, 0xd7, 0x53, 0xd1, 0x7e, 0x9d, 0xa5, 0x0b,
	0x7c, 0x35, 0x25, 0x3e, 0x0e, 0xa4, 0xf6, 0xe1, 0xd2, 0xf8, 0x77, 0x02, 0x4a, 0x83, 0xa9, 0x63,
	0x53, 0x1c, 0x32, 0x5e, 0xae, 0xbb, 0xef, 0xc2, 0xed, 0x19, 0x47, 0xb0, 0x22, 0xe3, 0x80, 0x66,
	0x96, 0x05, 0xb8, 0x1b, 0x32, 0xd9, 0x24, 0xc0, 0x07, 0xb0, 0x23, 0x89, 0x70, 0xc6, 0x36, 0x65,
	0x71, 0x23, 0xfc, 0x57, 0x17, 0x1b, 0xcd, 0x39, 0x1c, 0xbd, 0x09, 0xa0, 0x60, 0x65, 0xb8, 0xc0,
	0x0a, 0x24, 0x6a, 0x86, 0xec, 0x92, 0x19, 0x1e, 0x83, 0x24, 0xa8, 0x94, 0xe1, 0x9c, 0x2a, 0x6f,
	0x58, 0x8a, 0x0d, 0x17, 0x90, 0xd2, 0xd1, 0x6f, 0xed, 0xf3, 0x1f, 0x81, 0x32, 0x04, 0xdc, 0x64,
	0x4e, 0xf8, 0x53, 0x02, 0xca, 0xbc, 0xca, 0x9b, 0x78, 0x48, 0xa6, 0xac, 0xa1, 0x63, 0x26, 0x23,
	0x0e, 0x76, 0x29, 0xa1, 0xa1, 0x37, 0xcd, 0xd7, 0xe8, 0x19, 0xa4, 0x95, 0x01, 0xfa, 0x6d, 0x21,
	0x46, 0xe4, 0xf8, 0xc1, 0xfc, 0x8b, 0x0f, 0xd4, 0x1c, 0xdd, 0x38, 0x80, 0x52, 0x04, 0xcc, 0xc6,
	0xd7, 0x41, 0x8f, 0x0f, 0xb2, 0x79, 0xc8, 0x1c, 0x99, 0x9d, 0x41, 0x57, 0x4f, 0x70, 0x60, 0xbb,
	0xf5, 0xbd, 0x9e, 0x34, 0xfe, 0x9c, 0x80, 0x6c, 0xad, 0x7e, 0xbc, 0xce, 0xe5, 0x3e, 0x66, 0xb6,
	0x96, 0xe4, 0xa4, 0x92, 0x77, 0x62, 0x44, 0x31, 0x17, 0x58, 0xd1, 0xeb, 0x49, 0xad, 0x5c, 0x4f,
	0x96, 0x77, 0x11, 0xcc, 0x11, 0x53, 0x8f, 0x0b, 0x55, 0x9d, 0x13, 0x3b, 0xf4, 0xc6, 0x0e, 0xf6,
	0x05, 0x49, 0xb9, 0x6f, 0xfc, 0x35, 0x09, 0xb0, 0xb0, 0xe4, 0x8a, 0x5b, 0xc6, 0xf6, 0xb2, 0x71,
	0xcf, 0x14, 0xd1, 0xb9, 0x38, 0xbd, 0x34, 0x17, 0xab, 0xa1, 0x91, 0x89, 0x84, 0xc6, 0x66, 0x37,
	0x9b, 0xe7, 0xe6, 0x9c, 0x9a, 0x9b, 0x9f, 0xa9, 0x2f, 0x1f, 0x1a, 0xbf, 0xb8, 0xca, 0x92, 0x4b,
	0xc4, 0x3d, 0x80, 0xb0, 0x7e, 0xe7, 0xd2, 0xc5, 0x3e, 0x2b, 0xc7, 0x79, 0xd9, 0xef, 0xb0, 0xb5,
	0xa8, 0xc8, 0x7c, 0xba, 0x01, 0xa1, 0x10, 0xfb, 0x8e, 0x3c, 0x54, 0x84, 0x8f, 0x13, 0xb7, 0x94,
	0x27, 0x8b, 0x84, 0xf1, 0xbe, 0xea, 0xda, 0x3f, 0xd1, 0xdc, 0x3f, 0x00, 0xe0, 0x86, 0x6f, 0x35,
	0x62, 0xa2, 0xdf, 0xf0, 0xe1, 0x8e, 0x7a, 0x39, 0x5b, 0x47, 0x49, 0x15, 0x0a, 0xa7, 0x8b, 0xf3,
	0xd2, 0x83, 0x56, 0x2f, 0x5d, 0x45, 0x32, 0xfe, 0x96, 0x84, 0x82, 0xb2, 0x79, 0xa3, 0x49, 0x40,
	0x35, 0x61, 0x2a, 0x6a, 0xc2, 0x88, 0x0b, 0xa7, 0xb7, 0x77, 0xe1, 0xcc, 0xea, 0xd5, 0x0f, 0xf9,
	0xd5, 0x67, 0xc5, 0xd5, 0xf3, 0xc5, 0x1a, 0x87, 0xb8, 0x07, 0x59, 0xd9, 0x42, 0x6b, 0xe1, 0x43,
	0x14, 0xef, 0x9e, 0x9f, 0x40, 0x86, 0x19, 0x08, 0xf3, 0xeb, 0x2e, 0x57, 0xef, 0x2d, 0x1b, 0x84,
	0x9b, 0x12, 0x9b, 0x02, 0xc9, 0x78, 0x0a, 0x19, 0xbe, 0x46, 0x45, 0xd0, 0x6a, 0xf5, 0x7a, 0xb3,
	0xdb, 0x6f, 0x36, 0xf4, 0x5b, 0xa8, 0x00, 0xb9, 0x6e, 0xb3, 0xdd, 0x68, 0xb5, 0x8f, 0xf4, 0x04,
	0xdb, 0x32, 0x9b, 0xdf, 0x34, 0xeb, 0x6c, 0x2b, 0x69, 0x9c, 0xc1, 0x5d, 0x13, 0x0f, 0x31, 0xb9,
	0xc0, 0xce, 0x6b, 0x5e, 0xdc, 0xcf, 0x21, 0x13, 0x6c, 0xbc, 0x32, 0xb1, 0x6d, 0x5c, 0xc2, 0x4e,
	0x1b, 0x5f, 0x46, 0x7c, 0xe4, 0xff, 0x92, 0x49, 0x8c, 0x09, 0xec, 0x8a, 0xc2, 0xb5, 0xc4, 0x7b,
	0xd9, 0x5b, 0xe2, 0x0a, 0x42, 0x32, 0xae, 0x20, 0x6c, 0x66, 0x67, 0x80, 0x3e, 0x70, 0xb9, 0xca,
	0x82, 0x5f, 0x5c, 0xb0, 0x3c, 0x06, 0x74, 0x4c, 0x02, 0xba, 0x08, 0xbd, 0x60, 0xdd, 0xb0, 0xf3,
	0x1e, 0xdc, 0x61, 0x98, 0x8a, 0xe8, 0x6b, 0x51, 0x3f, 0x64, 0x6d, 0x6a, 0xe4, 0x2a, 0xf9, 0x80,
	0x24, 0xe6, 0xb3, 0x39, 0xfb, 0x1c, 0x5f, 0xb7, 0x9c, 0xf7, 0xff, 0x9e, 0x04, 0x58, 0x5c, 0x27,
	0xca, 0x42, 0xb2, 0xf3, 0x5c, 0xf8, 0xca, 0xa0, 0xfd, 0xbc, 0xdd, 0xf9, 0xae, 0xad, 0x27, 0xd0,
	0x5d, 0xd8, 0xe9, 0xf5, 0x3b, 0x66, 0xed, 0xa8, 0x69, 0xb5, 0x3b, 0x7d, 0xeb, 0xb0, 0x33, 0x68,
	0x37, 0xf4, 0x24, 0xda, 0x87, 0x7b, 0x21, 0xb8, 0x76, 0x6c, 0x36, 0x6b, 0x8d, 0xdf, 0x5a, 0xcd,
	0xef, 0x5b, 0xbd, 0x7e, 0x4f, 0x4f, 0xa1, 0x07, 0x50, 0x09, 0xf7, 0xba, 0x4d, 0xf3, 0xa4, 0xd5,
	0xeb, 0xb5, 0x3a, 0xed, 0x46, 0xb3, 0xdd, 0x6a, 0x36, 0xf4, 0x34, 0xda, 0x83, 0xbb, 0xf5, 0x4e,
	0xbb, 0xdf, 0xfc, 0xbe, 0x6f, 0xb1, 0x5a, 0x63, 0x99, 0xcd, 0x6f, 0x07, 0x2d, 0xb3, 0xd9, 0xd0,
	0x33, 0x48, 0x87, 0x62, 0xb7, 0xd6, 0xff, 0xda, 0x6a, 0xb5, 0x5f, 0xd4, 0x8e, 0x5b, 0x0d, 0x3d,
	0xcb, 0x90, 0xbb, 0x83, 0xaf, 0x8e, 0x5b, 0x75, 0xeb, 0xb8, 0xd5, 0x7e, 0xae, 0x48, 0x90, 0x63,
	0x5c, 0xd4, 0x2d, 0x79, 0xc6, 0x6a, 0xd4, 0xfa, 0x4d, 0x5d, 0x43, 0x8f, 0xe0, 0x41, 0xdc, 0x6e,
	0xb7, 0xd6, 0xeb, 0x7d, 0xd7, 0x31, 0x1b, 0x7a, 0x9e, 0x91, 0x56, 0x15, 0xeb, 0x0d, 0xba, 0xdd,
	0x8e, 0xc9, 0x22, 0x02, 0x10, 0x82, 0x32, 0x17, 0x6d, 0xc1, 0xae, 0x80, 0x76, 0xa0, 0xd4, 0xef,
	0x3c, 0x6f, 0xb6, 0xe7, 0xc2, 0x15, 0x99, 0x0d, 0x44, 0x16, 0xb5, 0x7a, 0x5f, 0xd7, 0x4c, 0xd5,
	0x3e, 0xa5, 0xea, 0x8f, 0x49, 0x48, 0xd7, 0x66, 0xf4, 0x0c, 0x7d, 0x01, 0xe5, 0xe8, 0xc3, 0x0e,
	0x0a, 0x03, 0x78, 0xe9, 0xb5, 0x67, 0x1f, 0x89, 0x67, 0x23, 0xf5, 0xb9, 0xc6, 0xb8, 0x85, 0x3e,
	0x05, 0xd4, 0x20, 0xc1, 0xc4, 0x76, 0xe9, 0x58, 0xa1, 0x51, 0x52, 0x71, 0x5f, 0xed, 0xef, 0x2c,
	0xde, 0xcb, 0x16, 0x27, 0xbf, 0x81, 0xdd, 0xb8, 0x87, 0x57, 0xf4, 0x60, 0xc1, 0x7f, 0x35, 0xf1,
	0xaf, 0x91, 0xa2, 0x01, 0x95, 0xb9, 0x14, 0xcb, 0xf4, 0x96, 0x64, 0x79, 0x63, 0xb9, 0xaf, 0x99,
	0x53, 0xa9, 0xfe, 0x27, 0x07, 0xb9, 0x1e, 0xf5, 0x7c, 0x7b, 0x84, 0xd1, 0x47, 0x90, 0xaf, 0xfb,
	0xd8, 0xa6, 0xb8, 0x41, 0x7c, 0x54, 0x14, 0x67, 0xc4, 0xc4, 0x2f, 0x45, 0x88, 0xbc, 0x93, 0x1a,
	0xb7, 0xd0, 0x13, 0xc8, 0x36, 0xf0, 0x18, 0xb3, 0xcc, 0x76, 0x03, 0xec, 0xf7, 0x21, 0x7d, 0xe2,
	0x5d, 0x84, 0xb8, 0xf2, 0xb1, 0x60, 0x0d, 0xee, 0x53, 0xc8, 0xb5, 0xdc, 0x60, 0x8a, 0x87, 0x74,
	0x89, 0xf4, 0xdd, 0xe8, 0xe3, 0xd3, 0xe2, 0xc4, 0x33, 0x80, 0x45, 0x48, 0xde, 0xf0, 0xd0, 0xd3,
	0x04, 0xfa, 0x04, 0x8a, 0x3d, 0x6a, 0xfb, 0x94, 0x8f, 0xe7, 0xfd, 0x2b, 0x69, 0xb9, 0xf0, 0x59,
	0x77, 0xff, 0x8e, 0xfa, 0x6e, 0xb8, 0x60, 0xf6, 0x19, 0x00, 0x3f, 0x20, 0xa6, 0xd9, 0xa2, 0x44,
	0xe2, 0xab, 0xfd, 0xbd, 0xd5, 0xc7, 0x80, 0xf9, 0xc1, 0xc7, 0x09, 0xf4, 0x31, 0x94, 0x0e, 0x89,
	0x4b, 0x82, 0xb3, 0x90, 0x23, 0xc8, 0xd3, 0x4d, 0xd7, 0x59, 0x63, 0x8c, 0x4f, 0xd8, 0x04, 0x6a,
	0x3b, 0xfc, 0xf5, 0x27, 0xaa, 0xd8, 0xbd, 0xa5, 0x79, 0x5b, 0xd5, 0xec, 0x53, 0x28, 0x31, 0x83,
	0x84, 0x53, 0x65, 0x10, 0x6b, 0x93, 0xe5, 0x09, 0x9a, 0x9f, 0xfc, 0x35, 0x1b, 0xeb, 0x6c, 0x67,
	0x3e, 0xf5, 0xea, 0x4b, 0xa8, 0x9b, 0xf9, 0x7e, 0xc6, 0x06, 0x2f, 0x3e, 0x52, 0x6d, 0x20, 0x10,
	0xaf, 0xe8, 0xe7, 0x50, 0x10, 0x22, 0xf3, 0xb9, 0x6d, 0x49, 0xe0, 0xbd, 0xd5, 0x71, 0x54, 0x65,
	0x5b, 0x83, 0x3b, 0x73, 0xb6, 0xca, 0x48, 0xba, 0x1b, 0x73, 0x6a, 0x1d, 0xfb, 0x2a, 0x14, 0x25,
	0x28, 0x8e, 0x7f, 0xfc, 0x99, 0x0f, 0x20, 0xdb, 0xc3, 0xb4, 0x56, 0x3f, 0x46, 0xe2, 0x89, 0x59,
	0xf4, 0xe2, 0x6b, 0x90, 0x0f, 0x20, 0x2f, 0x6a, 0xde, 0x0d, 0xf1, 0x3f, 0x04, 0x6d, 0xe0, 0x06,
	0x37, 0x26, 0xff, 0x11, 0x68, 0x47, 0x98, 0xf2, 0x9f, 0x19, 0xa4, 0x1f, 0x87, 0x3f, 0x49, 0xc8,
	0x03, 0x91, 0x5f, 0x20, 0x8c, 0x5b, 0xd5, 0x1f, 0x13, 0xfc, 0x27, 0xc5, 0x11, 0xf6, 0xd1, 0x13,
	0xc8, 0x1d, 0x61, 0xda, 0xb7, 0x47, 0x81, 0xe4, 0x24, 0x7e, 0x6a, 0xdc, 0xd7, 0x17, 0x0b, 0xc5,
	0xd8, 0x42, 0xeb, 0xbe, 0x3d, 0x8a, 0x22, 0x6f, 0xd0, 0xe2, 0xc6, 0xe8, 0xd5, 0x7f, 0x65, 0x21,
	0x23, 0x1a, 0xc7, 0x2f, 0x40, 0x17, 0xf9, 0x48, 0x99, 0x23, 0x44, 0xc3, 0xb3, 0x18, 0xb4, 0x37,
	0xe4, 0x36, 0x54, 0x03, 0x5d, 0x98, 0x5b, 0x39, 0x2f, 0x78, 0x46, 0x46, 0xe6, 0x4d, 0x24, 0xbe,
	0x84, 0x1d, 0x99, 0x87, 0x56, 0x64, 0x58, 0x74, 0xdd, 0x9b, 0x08, 0x7c, 0xc6, 0x5f, 0xa9, 0xbc,
	0x73, 0xbc, 0xe9, 0x7c, 0xbc, 0xdd, 0x8e, 0xe0, 0xf6, 0x52, 0x3b, 0x82, 0x04, 0xa3, 0xd5, 0x26,
	0x65, 0x83, 0x04, 0x4f, 0x13, 0xa8, 0x01, 0xe5, 0x9a, 0xe3, 0xa8, 0x2d, 0xf9, 0xbd, 0xd0, 0x8a,
	0xd1, 0xe6, 0x6b, 0xbf, 0xb2, 0xd2, 0x26, 0xaa, 0xb5, 0x6b, 0x67, 0xa5, 0x61, 0x43, 0x7b, 0x8a,
	0x39, 0xb7, 0xa2, 0xa5, 0x2f, 0xf7, 0x4f, 0xa8, 0x32, 0xd7, 0x6d, 0xa9, 0xad, 0xda, 0x44, 0x89,
	0x67, 0xab, 0x52, 0xa4, 0xb3, 0x43, 0x22, 0xb3, 0x2d, 0x77, 0x7b, 0x6b, 0x8c, 0xfc, 0x1b, 0x28,
	0x1f, 0x61, 0x95, 0xe3, 0xea, 0xed, 0x6c, 0x52, 0xa4, 0x2e, 0x5a, 0xc6, 0x48, 0x87, 0x17, 0x2c,
	0x17, 0x91, 0xfd, 0x30, 0x07, 0xad, 0x36, 0xf4, 0x32, 0x75, 0xa1, 0x13, 0x6f, 0xe6, 0x46, 0xa9,
	0xa0, 0xbb, 0x71, 0xa7, 0xd6, 0xa9, 0x51, 0x87, 0xdd, 0x81, 0x3b, 0xf9, 0xdf, 0x88, 0x54, 0xbf,
	0x82, 0x5c, 0xd7, 0xc7, 0x17, 0x04, 0x5f, 0xa2, 0x5f, 0x42, 0x81, 0x95, 0x80, 0x70, 0x79, 0xe3,
	0xaa, 0xf3, 0x32, 0xcb, 0xff, 0x61, 0xe1, 0x17, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x94, 0x4c,
	0x70, 0x3a, 0xc2, 0x20, 0x00, 0x00,
}
